<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Smart Coin™ — Donor Universe 3D (Visibility Fix + Debug)</title>
<style>
  :root{ --bg:#000; --panel:#111826; --text:#eaf0ff; --muted:#9aa3c9; --border:#1f2a4d; --accent:#6ee7ff; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #app{position:relative;width:100%;height:100vh;min-height:560px;background:#000;overflow:hidden}
  canvas#gl{position:absolute; inset:0; width:100%; height:100%; display:block}
  #status{position:fixed;left:10px;bottom:10px;z-index:10;background:var(--panel);color:var(--muted);
    border:1px solid var(--border);border-radius:8px;padding:6px 10px;font-size:12px;max-width:78vw;white-space:pre-wrap}
  #counters{position:fixed;left:50%;top:10px;transform:translateX(-50%);z-index:10;display:flex;gap:10px}
  .pill{background:var(--panel);border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:13px;opacity:.96}
  .pill b{font-weight:700}
  #timeline{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);z-index:10;width:min(520px,70vw);height:8px;
    background:var(--panel);border:1px solid var(--border);border-radius:999px;overflow:hidden;box-shadow:0 2px 10px rgba(0,0,0,.25)}
  #tlFill{height:100%;width:0%;background:var(--accent);opacity:.95}
</style>
</head>
<body>
<div id="app"><canvas id="gl"></canvas></div>

<div id="counters">
  <div class="pill">Coins: <b id="coinsVal">0</b></div>
  <div class="pill">Raised: <b id="raisedVal">$0</b></div>
</div>

<div id="timeline"><div id="tlFill"></div></div>
<div id="status">Status: loading… (Tips: mouse wheel = zoom, G = show all, Shift+B = restart)</div>

<script>
/*** utils ***/
const $=(id)=>document.getElementById(id);
const statusEl=$('status'), tlFill=$('tlFill'), coinsVal=$('coinsVal'), raisedVal=$('raisedVal');
const setStatus=(m)=>statusEl.textContent='Status: '+m;
const fmtMoney=(n)=>n.toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
const easeOutCubic=t=>1-Math.pow(1-Math.min(1,Math.max(0,t)),3);
function xmur3(str){for(var i=0,h=1779033703^str.length;i<str.length;i++)h=Math.imul(h^str.charCodeAt(i),3432918353),h=h<<13|h>>>19;return function(){h=Math.imul(h^(h>>>16),2246822507);h=Math.imul(h^(h>>>13),3266489909);return(h^(h>>>16))>>>0}}
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
function makeRNG(s){if(!s) return Math.random; const seed=xmur3(String(s))(); return mulberry32(seed)}
function roundTo(v,step){return Math.round(v/step)*step}
function poisson(lambda,rand){if(lambda<=0)return 0; const L=Math.exp(-lambda); let k=0,p=1; do{k++;p*=rand()}while(p>L); return k-1}
function sampleGift(rand){const u=rand(); if(u<0.60) return 50; if(u<0.78) return roundTo(50+rand()*100,5); if(u<0.90) return roundTo(150+rand()*350,10); if(u<0.98) return roundTo(500+rand()*1500,25); return roundTo(2000+rand()*3000,50);}

/*** params ***/
const P={ roots:250,
  lightDepth:10, lightProb:.85, lightFan:1.5, lightDecay:.90,
  extraDepth:9,  extraProb:.85, extraFan:1.8, extraDecay:.88,
  radius:800, jitter:36, cap:20000, seed:'universe-250-visible'
};

/*** model ***/
function buildGraph(P){
  const rand=makeRNG(P.seed), randJ=makeRNG(P.seed+'j'), randG=makeRNG(P.seed+'g');
  const ROOT_STAGGER=140, STEP_LIGHT=560, STEP_GREEN=420, STEP_RED=300;
  const nodes=[], links=[], roots=[]; let id=0;
  function addNode(type,parent=null,branch='light',bdepth=0,birth=0){
    if(nodes.length>=P.cap) return null;
    const gift=sampleGift(randG);
    const n={id:id++,type,parent,children:[],branch,bdepth,birth,gift,x:0,y:0,z:0};
    nodes.push(n);
    if(parent!=null){links.push({source:parent,target:n.id}); nodes[parent].children.push(n.id);}
    return n;
  }
  for(let i=0;i<P.roots;i++){const b=i*ROOT_STAGGER+rand()*80; const r=addNode('dark',null,'light',0,b); if(r) roots.push(r.id);}
  const q=roots.map(id=>({id}));
  while(q.length && nodes.length<P.cap){
    const pid=q.shift().id, p=nodes[pid];
    if(p.branch==='light' && p.bdepth<P.lightDepth){
      const scale=Math.pow(P.lightDecay, Math.max(0,p.bdepth));
      if(rand()<P.lightProb*scale){
        let k=poisson(Math.max(0,P.lightFan*scale), rand);
        if(k>0){
          const lb=p.birth+STEP_LIGHT*(0.8+0.4*rand());
          const c=addNode('light',pid,'light',p.bdepth+1,lb); if(c) q.push({id:c.id});
          for(let i=1;i<k;i++){
            const gb=p.birth+STEP_GREEN*(0.65+0.5*rand());
            const g=addNode('green',pid,'extra',1,gb); if(g) q.push({id:g.id});
          }
        }
      }
    } else if(p.branch==='extra' && p.bdepth<P.extraDepth){
      const scale=Math.pow(P.extraDecay, Math.max(0,p.bdepth-1));
      if(rand()<P.extraProb*scale){
        let k=poisson(Math.max(0,P.extraFan*scale), rand);
        for(let i=0;i<k;i++){
          const rb=p.birth+STEP_RED*(0.6+0.5*rand());
          const r=addNode('red',pid,'extra',p.bdepth+1,rb); if(r) q.push({id:r.id});
        }
      }
    }
  }
  function fibSphere(n,r=P.radius){const pts=[],phi=Math.PI*(3-Math.sqrt(5));
    for(let i=0;i<n;i++){const y=1-(i/Math.max(1,n-1))*2; const rad=Math.sqrt(Math.max(0,1-y*y)); const th=phi*i;
      pts.push({x:Math.cos(th)*rad*r,y:y*r,z:Math.sin(th)*rad*r});}
    return pts;
  }
  const rootsObjs=nodes.filter(n=>n.type==='dark'), pts=fibSphere(rootsObjs.length,P.radius);
  rootsObjs.forEach((n,i)=>{n.x=pts[i].x; n.y=pts[i].y; n.z=pts[i].z;});
  nodes.forEach(n=>{
    if(n.type!=='dark'){
      const p=nodes[n.parent]||{x:0,y:0,z:0};
      const spread=P.jitter*(1+0.04*Math.max(0,n.bdepth-1));
      const j=()=> (randJ()*2-1)*spread;
      n.x=p.x+j(); n.y=p.y+j(); n.z=p.z+j();
    }
  });
  const byBirth=nodes.slice().sort((a,b)=>a.birth-b.birth);
  const birthsSorted=byBirth.map(n=>n.birth);
  let acc=0; const giftPrefix=byBirth.map(n=>{ acc+=n.gift; return acc; });
  const maxBirth=nodes.reduce((m,n)=>Math.max(m,n.birth),0);
  return {nodes,links,roots,birthsSorted,giftPrefix,maxBirth,byBirth};
}

/*** mat4 ***/
function mat4Perspective(out,fovy,aspect,near,far){const f=1/Math.tan(fovy/2),nf=1/(near-far);out[0]=f/aspect;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=f;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=(far+near)*nf;out[11]=-1;out[12]=0;out[13]=0;out[14]=2*far*near*nf;out[15]=0;return out;}
function mat4Look(out,eye,center,up){const [ex,ey,ez]=eye,[cx,cy,cz]=center,[ux,uy,uz]=up;let zx=ex-cx,zy=ey-cy,zz=ez-cz;let zl=1/Math.hypot(zx,zy,zz);zx*=zl;zy*=zl;zz*=zl;let xx=uy*zz-uz*zy,xy=uz*zx-ux*zz,xz=ux*zy-uy*zx;let xl=1/Math.hypot(xx,xy,xz);xx*=xl;xy*=xl;xz*=xl;let yx=zy*xz-zz*xy,yy=zz*xx-zx*xz,yz=zx*xy-zy*xx;out[0]=xx;out[1]=yx;out[2]=zx;out[3]=0;out[4]=xy;out[5]=yy;out[6]=zy;out[7]=0;out[8]=xz;out[9]=yz;out[10]=zz;out[11]=0;out[12]=-(xx*ex+xy*ey+xz*ez);out[13]=-(yx*ex+yy*ey+yz*ez);out[14]=-(zx*ex+zy*ey+zz*ez);out[15]=1;return out;}
function mat4Mul(out,a,b){const o=new Float32Array(16);for(let r=0;r<4;r++)for(let c=0;c<4;c++){o[r*4+c]=a[r*4+0]*b[0*4+c]+a[r*4+1]*b[1*4+c]+a[r*4+2]*b[2*4+c]+a[r*4+3]*b[3*4+c];}out.set(o);return out;}

/*** WebGL setup ***/
const canvas=document.getElementById('gl');
const gl=canvas.getContext('webgl',{antialias:true, alpha:false});
if(!gl){ setStatus('Error: WebGL not available'); throw new Error('WebGL not available'); }
// IMPORTANT: enable blending so alpha/edges show up
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
gl.enable(gl.DEPTH_TEST);

function resizeGL(){const dpr=window.devicePixelRatio||1; const w=canvas.clientWidth, h=canvas.clientHeight; canvas.width=Math.max(1,w*dpr); canvas.height=Math.max(1,h*dpr); gl.viewport(0,0,canvas.width,canvas.height);}
window.addEventListener('resize',resizeGL);

/*** Shaders ***/
const vsPoints=`
attribute vec3 aPos;
attribute vec3 aCol;
attribute float aBirth;
attribute float aSize; // base px when clip.w == 1
uniform mat4 uMVP;
uniform float uTime;
uniform float uRamp;
uniform float uPxScale; // = height / (2*tan(fovy/2))
varying vec3 vCol;
varying float vA;
void main(){
  vec4 clip=uMVP*vec4(aPos,1.0);
  gl_Position=clip;
  float a=clamp((uTime-aBirth)/uRamp,0.0,1.0);
  vA=a;
  vCol=aCol;
  float ps=uPxScale/max(0.0001,clip.w);
  float sz=max(2.0, aSize*ps*a + 2.0); // ensure minimum size on screen
  gl_PointSize=sz;
}`;
const fsPoints=`
precision mediump float;
varying vec3 vCol; varying float vA;
void main(){
  vec2 uv=gl_PointCoord*2.0-1.0;
  float r2=dot(uv,uv);
  if(r2>1.0) discard;
  float edge=smoothstep(1.0,0.6,1.0-r2);
  gl_FragColor=vec4(vCol, vA*edge);
}`;
const vsLines=`attribute vec3 aPos; uniform mat4 uMVP; void main(){ gl_Position=uMVP*vec4(aPos,1.0); }`;
const fsLines=`precision mediump float; uniform vec4 uColor; void main(){ gl_FragColor=uColor; }`;

function compile(type,src){const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s;}
function program(vs,fs){const p=gl.createProgram(); gl.attachShader(p,compile(gl.VERTEX_SHADER,vs)); gl.attachShader(p,compile(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p;}
const progPoints=program(vsPoints,fsPoints), progLines=program(vsLines,fsLines);

/*** Model + buffers ***/
const model=buildGraph(P);
const N=model.nodes.length, E=model.links.length;
const COLOR_DARK=[0x1e/255,0x3a/255,0x8a/255], COLOR_LIGHT=[0x93/255,0xc5/255,0xfd/255],
      COLOR_GREEN=[0x22/255,0xc5/255,0x5e/255], COLOR_RED=[0xef/255,0x44/255,0x44/255];

const nodePos=new Float32Array(N*3), nodeCol=new Float32Array(N*3), nodeBirth=new Float32Array(N);
for(let i=0;i<N;i++){const n=model.nodes[i]; nodePos.set([n.x,n.y,n.z],i*3); const c=n.type==='dark'?COLOR_DARK:n.type==='light'?COLOR_LIGHT:n.type==='green'?COLOR_GREEN:COLOR_RED; nodeCol.set(c,i*3); nodeBirth[i]=n.birth;}
const edgePos=new Float32Array(E*6);
for(let i=0;i<E;i++){const l=model.links[i], a=model.nodes[l.source], b=model.nodes[l.target]; edgePos.set([a.x,a.y,a.z,b.x,b.y,b.z], i*6);}
const sorted=model.links.slice().sort((a,b)=> model.nodes[a.target].birth - model.nodes[b.target].birth);
const edgeGrowPos=new Float32Array(E*6), edgeGrowBirths=new Float32Array(E);
for(let i=0;i<E;i++){const l=sorted[i], a=model.nodes[l.source], b=model.nodes[l.target]; edgeGrowPos.set([a.x,a.y,a.z,b.x,b.y,b.z], i*6); edgeGrowBirths[i]=model.nodes[l.target].birth;}
function mkBuf(target,data,usage){const b=gl.createBuffer(); gl.bindBuffer(target,b); gl.bufferData(target,data,usage||gl.STATIC_DRAW); return b;}
const bufPos=mkBuf(gl.ARRAY_BUFFER,nodePos), bufCol=mkBuf(gl.ARRAY_BUFFER,nodeCol), bufBirth=mkBuf(gl.ARRAY_BUFFER,nodeBirth),
      bufEdges=mkBuf(gl.ARRAY_BUFFER,edgePos), bufGrow=mkBuf(gl.ARRAY_BUFFER,edgeGrowPos);
const nodeSize=new Float32Array(N); const bufSize=gl.createBuffer();

/*** Camera & Bloom ***/
let yaw=0, pitch=0, dist=1400, panX=0, panY=0; // pulled camera farther back
let dragging=false, rotating=false, lastX=0,lastY=0;
canvas.addEventListener('mousedown',e=>{dragging=true; rotating=(e.button===0 && !e.ctrlKey); lastX=e.clientX; lastY=e.clientY;});
window.addEventListener('mouseup',()=>dragging=false);
window.addEventListener('mousemove',e=>{if(!dragging) return; const dx=e.clientX-lastX,dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; if(rotating){yaw+=dx*0.005; pitch=Math.max(-1.2,Math.min(1.2,pitch+dy*0.005));} else {panX+=dx; panY+=dy;}});
canvas.addEventListener('wheel',e=>{e.preventDefault(); dist=Math.max(200,Math.min(4000,dist+e.deltaY));},{passive:false});
const BLOOM={playing:true,t:0,duration:model.maxBirth+2000,start:performance.now(), forceAll:false};

/*** Influence + counters ***/
const visibleMask=new Uint8Array(N), subCoins=new Uint32Array(N), subGifts=new Float64Array(N);
function upperBound(arr,val){let lo=0,hi=arr.length; while(lo<hi){const mid=(lo+hi)>>1; if(arr[mid]<=val) lo=mid+1; else hi=mid;} return lo;}
function updateCounters(){
  const idx=upperBound(model.birthsSorted, BLOOM.t);
  const coins=idx;
  const gifts=idx?model.giftPrefix[idx-1]:0;
  coinsVal.textContent=coins.toLocaleString('en-US');
  raisedVal.textContent=fmtMoney(Math.round(coins*50 + gifts));
}
function recomputeInfluence(){
  const k = BLOOM.forceAll ? N : upperBound(model.birthsSorted, BLOOM.t);
  visibleMask.fill(0); subCoins.fill(0); subGifts.fill(0);
  for(let i=0;i<k;i++){const id=model.byBirth[i].id; visibleMask[id]=1; subCoins[id]=1; subGifts[id]=model.nodes[id].gift;}
  for(let i=k-1;i>=0;i--){const id=model.byBirth[i].id; const n=model.nodes[id]; if(n.parent!=null && visibleMask[n.parent]){ subCoins[n.parent]+=subCoins[id]; subGifts[n.parent]+=subGifts[id]; }}
  // size: base + influence boost
  const baseOf=t=>t==='dark'?5.2 : t==='light'?4.0 : t==='green'?4.4 : 3.8;
  for(let i=0;i<N;i++){
    if(!visibleMask[i]){ nodeSize[i]=0.01; continue; }
    const raised=subCoins[i]*50 + subGifts[i];
    const boost=Math.min(18, Math.log1p(raised)/Math.log(1+5000)*18);
    nodeSize[i]=baseOf(model.nodes[i].type)+boost;
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, bufSize);
  gl.bufferData(gl.ARRAY_BUFFER, nodeSize, gl.DYNAMIC_DRAW);
}

/*** Render ***/
function resizeGL(){const dpr=window.devicePixelRatio||1; const w=canvas.clientWidth, h=canvas.clientHeight; canvas.width=Math.max(1,w*dpr); canvas.height=Math.max(1,h*dpr); gl.viewport(0,0,canvas.width,canvas.height);}
window.addEventListener('resize',resizeGL);

function render(){
  if(BLOOM.playing){ BLOOM.t=Math.min(BLOOM.duration, performance.now()-BLOOM.start); if(BLOOM.t>=BLOOM.duration){ BLOOM.playing=false; document.getElementById('btnBloom').textContent='⏵ Bloom'; } }
  updateCounters();
  recomputeInfluence();
  tlFill.style.width=`${Math.min(100,(BLOOM.t/BLOOM.duration)*100)}%`;

  resizeGL();
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const dpr=window.devicePixelRatio||1, w=canvas.width/dpr, h=canvas.height/dpr;
  const proj=new Float32Array(16), view=new Float32Array(16), mvp=new Float32Array(16);
  mat4Perspective(proj, Math.PI/3, w/h, 0.1, 5000);
  const cx=Math.sin(yaw)*dist*Math.cos(pitch), cy=Math.sin(pitch)*dist, cz=Math.cos(yaw)*dist*Math.cos(pitch);
  const panScale=dist/900;
  mat4Look(view, [cx - panX*panScale, cy + panY*panScale, cz], [ -panX*panScale, 0+panY*panScale, 0 ], [0,1,0]);
  mat4Mul(mvp, proj, view);

  // base edges (brighter for visibility)
  gl.useProgram(progLines);
  gl.bindBuffer(gl.ARRAY_BUFFER, bufEdges);
  const aPosL=gl.getAttribLocation(progLines,'aPos'); gl.enableVertexAttribArray(aPosL);
  gl.vertexAttribPointer(aPosL,3,gl.FLOAT,false,0,0);
  gl.uniformMatrix4fv(gl.getUniformLocation(progLines,'uMVP'),false,mvp);
  gl.uniform4f(gl.getUniformLocation(progLines,'uColor'), 0x5b/255,0x6b/255,0x95/255, 0.30);
  gl.drawArrays(gl.LINES,0,E*2);

  // cyan growth edges (full opacity for visibility)
  let lo=0,hi=edgeGrowBirths.length; const t = BLOOM.forceAll ? 1e12 : BLOOM.t;
  while(lo<hi){const mid=(lo+hi)>>1; if(edgeGrowBirths[mid]<=t) lo=mid+1; else hi=mid;}
  const segs=lo;
  if(segs>0){
    gl.bindBuffer(gl.ARRAY_BUFFER, bufGrow);
    gl.vertexAttribPointer(aPosL,3,gl.FLOAT,false,0,0);
    gl.uniform4f(gl.getUniformLocation(progLines,'uColor'), 110/255,231/255,255/255, 1.0);
    gl.drawArrays(gl.LINES,0,segs*2);
  }

  // points
  gl.useProgram(progPoints);
  // pos
  gl.bindBuffer(gl.ARRAY_BUFFER, bufPos); const aPos=gl.getAttribLocation(progPoints,'aPos'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0);
  // col
  gl.bindBuffer(gl.ARRAY_BUFFER, bufCol); const aCol=gl.getAttribLocation(progPoints,'aCol'); gl.enableVertexAttribArray(aCol); gl.vertexAttribPointer(aCol,3,gl.FLOAT,false,0,0);
  // birth
  gl.bindBuffer(gl.ARRAY_BUFFER, bufBirth); const aBirth=gl.getAttribLocation(progPoints,'aBirth'); gl.enableVertexAttribArray(aBirth); gl.vertexAttribPointer(aBirth,1,gl.FLOAT,false,0,0);
  // dynamic size
  gl.bindBuffer(gl.ARRAY_BUFFER, bufSize); const aSize=gl.getAttribLocation(progPoints,'aSize'); gl.enableVertexAttribArray(aSize); gl.vertexAttribPointer(aSize,1,gl.FLOAT,false,0,0);

  gl.uniformMatrix4fv(gl.getUniformLocation(progPoints,'uMVP'),false,mvp);
  gl.uniform1f(gl.getUniformLocation(progPoints,'uTime'), BLOOM.forceAll ? 1e12 : BLOOM.t);
  gl.uniform1f(gl.getUniformLocation(progPoints,'uRamp'), 420.0);
  // Correct pixel scale = height / (2*tan(fovy/2))
  gl.uniform1f(gl.getUniformLocation(progPoints,'uPxScale'), canvas.height / (2*Math.tan(Math.PI/3/2)));

  gl.drawArrays(gl.POINTS,0,N);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

/*** UI ***/
document.addEventListener('keydown',e=>{
  if(e.key==='b'||e.key==='B'){
    if(e.shiftKey){ BLOOM.t=0; BLOOM.playing=false; document.getElementById('btnBloom').textContent='⏵ Bloom'; tlFill.style.width='0%'; setStatus('reset'); }
    else { BLOOM.playing=!BLOOM.playing; document.getElementById('btnBloom').textContent=BLOOM.playing?'⏸ Bloom':'⏵ Bloom'; if(BLOOM.playing) BLOOM.start=performance.now()-BLOOM.t; setStatus(BLOOM.playing?'playing':'paused'); }
  }
  if(e.key==='g'||e.key==='G'){ BLOOM.forceAll=!BLOOM.forceAll; setStatus(BLOOM.forceAll?'debug: showing all nodes/edges':'debug off'); }
});
</script>
</body>
</html>
