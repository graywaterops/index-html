<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Smart Coin™ — WebGL 3D Debug (see the stars)</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#eaf0ff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #wrap{position:relative;height:100vh;overflow:hidden;background:#000}
  #gl{position:absolute;inset:0;width:100%;height:100%;display:block}
  #hud{position:fixed;left:10px;top:10px;z-index:2;font:12px/1.2 system-ui}
  .pill{display:inline-block;margin-right:8px;background:#111826;border:1px solid #1f2a4d;border-radius:999px;padding:6px 10px}
  #status{position:fixed;left:10px;bottom:10px;z-index:2;background:#111826;border:1px solid #1f2a4d;border-radius:8px;padding:6px 10px;font:12px system-ui;max-width:80vw}
  #bar{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);z-index:2;width:min(520px,70vw);height:8px;background:#111826;border:1px solid #1f2a4d;border-radius:999px;overflow:hidden}
  #fill{height:100%;width:0%;background:#6ee7ff}
</style>
</head>
<body>
<div id="wrap"><canvas id="gl"></canvas></div>
<div id="hud">
  <span class="pill">Coins: <b id="coins">0</b></span>
  <span class="pill">Raised: <b id="raised">$0</b></span>
  <span class="pill">Keys: <b>Y</b>=Yellow-Dots, <b>G</b>=Show-All, <b>B</b>=Play/Pause, <b>Shift+B</b>=Restart</span>
</div>
<div id="bar"><div id="fill"></div></div>
<div id="status">Status: loading…</div>

<script>
/*** tiny utils ***/
const $=id=>document.getElementById(id);
const statusEl=$('status'), fill=$('fill'), coinsEl=$('coins'), raisedEl=$('raised');
const setStatus= m => statusEl.textContent='Status: '+m;
const fmt$ = n => n.toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
function xmur3(str){for(var i=0,h=1779033703^str.length;i<str.length;i++)h=Math.imul(h^str.charCodeAt(i),3432918353),h=h<<13|h>>>19;return function(){h=Math.imul(h^(h>>>16),2246822507);h=Math.imul(h^(h>>>13),3266489909);return(h^(h>>>16))>>>0}}
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
function makeRNG(s){if(!s) return Math.random; const seed=xmur3(String(s))(); return mulberry32(seed)}
function roundTo(v,step){return Math.round(v/step)*step}
function poisson(lambda,rand){if(lambda<=0)return 0; const L=Math.exp(-lambda); let k=0,p=1; do{k++;p*=rand()}while(p>L); return k-1}
function gift(rand){const u=rand(); if(u<0.60) return 50;
  if(u<0.78) return roundTo(50+rand()*100,5);
  if(u<0.90) return roundTo(150+rand()*350,10);
  if(u<0.98) return roundTo(500+rand()*1500,25);
  return roundTo(2000+rand()*3000,50);
}

/*** model ***/
const P={roots:250, lightDepth:10, lightProb:.85, lightFan:1.5, lightDecay:.9,
         extraDepth:9, extraProb:.85, extraFan:1.8, extraDecay:.88,
         radius:800, jitter:36, cap:25000, seed:'universe-debug'};

function build(){
  const rand=makeRNG(P.seed), randJ=makeRNG(P.seed+'j'), randG=makeRNG(P.seed+'g');
  const ROOT_DT=140, DT_L=560, DT_G=420, DT_R=300;
  const nodes=[], links=[], roots=[];
  let id=0;
  function add(type,parent=null,branch='light',depth=0,birth=0){
    if(nodes.length>=P.cap) return null;
    const n={id:id++,type,parent,branch,depth,birth,gift:gift(randG),x:0,y:0,z:0,children:[]};
    nodes.push(n); if(parent!=null){links.push({source:parent,target:n.id}); nodes[parent].children.push(n.id);}
    return n;
  }
  for(let i=0;i<P.roots;i++){const b=i*ROOT_DT+rand()*80; const r=add('dark',null,'light',0,b); roots.push(r.id);}
  const q=roots.slice();
  while(q.length && nodes.length<P.cap){
    const pid=q.shift(); const p=nodes[pid];
    if(p.branch==='light' && p.depth<P.lightDepth){
      const scale=Math.pow(P.lightDecay, Math.max(0,p.depth));
      if(rand()<P.lightProb*scale){
        let k=poisson(Math.max(0,P.lightFan*scale), rand);
        if(k>0){
          const lb=p.birth+DT_L*(0.8+0.4*rand());
          const c=add('light', pid, 'light', p.depth+1, lb); q.push(c.id);
          for(let i=1;i<k;i++){ const gb=p.birth+DT_G*(0.65+0.5*rand()); const g=add('green', pid, 'extra', 1, gb); q.push(g.id); }
        }
      }
    } else if(p.branch==='extra' && p.depth<P.extraDepth){
      const scale=Math.pow(P.extraDecay, Math.max(0,p.depth-1));
      if(rand()<P.extraProb*scale){
        let k=poisson(Math.max(0,P.extraFan*scale), rand);
        for(let i=0;i<k;i++){ const rb=p.birth+DT_R*(0.6+0.5*rand()); const r=add('red', pid, 'extra', p.depth+1, rb); q.push(r.id); }
      }
    }
  }
  // layout
  function fib(n,r=P.radius){const pts=[],phi=Math.PI*(3-Math.sqrt(5));
    for(let i=0;i<n;i++){const y=1-(i/Math.max(1,n-1))*2; const rad=Math.sqrt(Math.max(0,1-y*y)); const th=phi*i;
      pts.push({x:Math.cos(th)*rad*r,y:y*r,z:Math.sin(th)*rad*r})} return pts;}
  const rootsObjs=nodes.filter(n=>n.type==='dark'); const pts=fib(rootsObjs.length,P.radius);
  rootsObjs.forEach((n,i)=>{n.x=pts[i].x;n.y=pts[i].y;n.z=pts[i].z;});
  nodes.forEach(n=>{
    if(n.type!=='dark'){ const p=nodes[n.parent]; const spread=P.jitter*(1+0.04*Math.max(0,n.depth-1));
      const j=()=> (randJ()*2-1)*spread; n.x=p.x+j(); n.y=p.y+j(); n.z=p.z+j();}
  });
  // birth prefix for counters
  const byBirth=nodes.slice().sort((a,b)=>a.birth-b.birth);
  const births=byBirth.map(n=>n.birth);
  let acc=0; const giftPrefix=byBirth.map(n=>{acc+=n.gift; return acc;});
  const maxBirth=nodes.reduce((m,n)=>Math.max(m,n.birth),0);
  return {nodes,links,roots,byBirth,births,giftPrefix,maxBirth};
}

/*** WebGL minimal engine ***/
const canvas=document.getElementById('gl');
const gl=canvas.getContext('webgl',{antialias:true,alpha:false});
if(!gl){ setStatus('Error: WebGL not available'); throw new Error('no webgl'); }
gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
gl.enable(gl.DEPTH_TEST);

function resize(){const dpr=window.devicePixelRatio||1; const w=canvas.clientWidth, h=canvas.clientHeight; canvas.width=w*dpr; canvas.height=h*dpr; gl.viewport(0,0,canvas.width,canvas.height);}
window.addEventListener('resize',resize); resize();

/* shaders */
const vsP=`attribute vec3 aPos; attribute vec3 aCol; attribute float aBirth; attribute float aSize;
uniform mat4 uMVP; uniform float uTime; uniform float uRamp; uniform float uPxScale; uniform float uForceAll;
varying vec3 vCol; varying float vA;
void main(){ vec4 c=uMVP*vec4(aPos,1.0); gl_Position=c;
  float a = (uForceAll>0.5)? 1.0 : clamp((uTime - aBirth)/uRamp,0.0,1.0);
  vA=a; vCol=aCol;
  float ps=uPxScale/max(0.0001,c.w);
  gl_PointSize = max(6.0, aSize*ps*a) + 2.0; }`;
const fsP=`precision mediump float; varying vec3 vCol; varying float vA;
uniform float uYellow;  // debug: 1 = force yellow opaque dots
void main(){
  if(uYellow>0.5){ gl_FragColor=vec4(1.0,1.0,0.0,1.0); return; }
  vec2 uv=gl_PointCoord*2.0-1.0; float r2=dot(uv,uv); if(r2>1.0) discard;
  float edge=smoothstep(1.0,0.6,1.0-r2); gl_FragColor=vec4(vCol, vA*edge);
}`;
const vsL=`attribute vec3 aPos; uniform mat4 uMVP; void main(){ gl_Position=uMVP*vec4(aPos,1.0); }`;
const fsL=`precision mediump float; uniform vec4 uCol; void main(){ gl_FragColor=uCol; }`;
function sh(t,s){const o=gl.createShader(t); gl.shaderSource(o,s); gl.compileShader(o); if(!gl.getShaderParameter(o,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(o)); return o;}
function prog(vs,fs){const p=gl.createProgram(); gl.attachShader(p,sh(gl.VERTEX_SHADER,vs)); gl.attachShader(p,sh(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p;}
const pP=prog(vsP,fsP), pL=prog(vsL,fsL);

/* model + buffers */
const model=build();
const N=model.nodes.length, E=model.links.length;
const C_D=[0x1e/255,0x3a/255,0x8a/255], C_L=[0x93/255,0xc5/255,0xfd/255], C_G=[0x22/255,0xc5/255,0x5e/255], C_R=[0xef/255,0x44/255,0x44/255];
const pos=new Float32Array(N*3), col=new Float32Array(N*3), birth=new Float32Array(N), size=new Float32Array(N);
function baseSize(t){return t==='dark'?5.2 : t==='light'?4.0 : t==='green'?4.4 : 3.8;}
for(let i=0;i<N;i++){
  const n=model.nodes[i];
  pos.set([n.x,n.y,n.z],i*3);
  const c=n.type==='dark'?C_D:n.type==='light'?C_L:n.type==='green'?C_G:C_R; col.set(c,i*3);
  birth[i]=n.birth; size[i]=baseSize(n.type)+8; // +8px boost for visibility
}
const epos=new Float32Array(E*6);
for(let i=0;i<E;i++){const l=model.links[i], a=model.nodes[l.source], b=model.nodes[l.target]; epos.set([a.x,a.y,a.z,b.x,b.y,b.z],i*6);}

function buf(target,data,usage){const b=gl.createBuffer(); gl.bindBuffer(target,b); gl.bufferData(target,data,usage||gl.STATIC_DRAW); return b;}
const bPos=buf(gl.ARRAY_BUFFER,pos), bCol=buf(gl.ARRAY_BUFFER,col), bBirth=buf(gl.ARRAY_BUFFER,birth), bSize=buf(gl.ARRAY_BUFFER,size);
const bEdges=buf(gl.ARRAY_BUFFER,epos);

/* camera */
let yaw=0, pitch=0, dist=1500, panX=0, panY=0, dragging=false, rotating=false, lx=0,ly=0;
canvas.addEventListener('mousedown',e=>{dragging=true; rotating=(e.button===0 && !e.ctrlKey); lx=e.clientX; ly=e.clientY;});
window.addEventListener('mouseup',()=>dragging=false);
window.addEventListener('mousemove',e=>{if(!dragging)return; const dx=e.clientX-lx, dy=e.clientY-ly; lx=e.clientX; ly=e.clientY;
  if(rotating){ yaw+=dx*0.005; pitch=Math.max(-1.2,Math.min(1.2,pitch+dy*0.005)); } else { panX+=dx; panY+=dy; }});
canvas.addEventListener('wheel',e=>{e.preventDefault(); dist=Math.max(200,Math.min(4000,dist+e.deltaY));},{passive:false});

/* mat4 */
function m4pers(out,fovy,aspect,near,far){const f=1/Math.tan(fovy/2),nf=1/(near-far); out[0]=f/aspect;out[5]=f;out[10]=(far+near)*nf;out[11]=-1;out[14]=2*far*near*nf; out[1]=out[2]=out[3]=out[4]=out[6]=out[7]=out[8]=out[9]=out[12]=out[13]=out[15]=0; return out;}
function m4look(out,eye,ctr,up){const [ex,ey,ez]=eye,[cx,cy,cz]=ctr,[ux,uy,uz]=up;let zx=ex-cx,zy=ey-cy,zz=ez-cz;let zl=1/Math.hypot(zx,zy,zz);zx*=zl;zy*=zl;zz*=zl;let xx=uy*zz-uz*zy,xy=uz*zx-ux*zz,xz=ux*zy-uy*zx;let xl=1/Math.hypot(xx,xy,xz);xx*=xl;xy*=xl;xz*=xl;let yx=zy*xz-zz*xy,yy=zz*xx-zx*xz,yz=zx*xy-zy*xx;out[0]=xx;out[1]=yx;out[2]=zx;out[3]=0;out[4]=xy;out[5]=yy;out[6]=zy;out[7]=0;out[8]=xz;out[9]=yz;out[10]=zz;out[11]=0;out[12]=-(xx*ex+xy*ey+xz*ez);out[13]=-(yx*ex+yy*ey+yz*ez);out[14]=-(zx*ex+zy*ey+zz*ez);out[15]=1;return out;}
function m4mul(out,a,b){const o=new Float32Array(16); for(let r=0;r<4;r++)for(let c=0;c<4;c++){o[r*4+c]=a[r*4+0]*b[0*4+c]+a[r*4+1]*b[1*4+c]+a[r*4+2]*b[2*4+c]+a[r*4+3]*b[3*4+c];} out.set(o); return out;}

/* bloom / counters */
const BLOOM={playing:true,t:0,duration:model.maxBirth+2000,start:performance.now(), showAll:false, yellow:false};
function ub(arr,val){let lo=0,hi=arr.length; while(lo<hi){const mid=(lo+hi)>>1; if(arr[mid]<=val) lo=mid+1; else hi=mid;} return lo;}
function updateCounters(){
  const idx = BLOOM.showAll ? model.nodes.length : ub(model.births, BLOOM.t);
  const coins=idx, gifts=idx?model.giftPrefix[idx-1]:0;
  coinsEl.textContent = coins.toLocaleString('en-US'); raisedEl.textContent = (coins*50+gifts).toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
}

/* render */
function resize(){const dpr=window.devicePixelRatio||1; const w=canvas.clientWidth,h=canvas.clientHeight; canvas.width=w*dpr; canvas.height=h*dpr; gl.viewport(0,0,canvas.width,canvas.height);} window.addEventListener('resize',resize); resize();
function render(){
  if(BLOOM.playing){ BLOOM.t=Math.min(BLOOM.duration, performance.now()-BLOOM.start);
    if(BLOOM.t>=BLOOM.duration){ BLOOM.playing=false; setStatus('done (press Shift+B to restart)'); }}
  updateCounters();
  fill.style.width = `${Math.min(100, (BLOOM.t/BLOOM.duration)*100)}%`;

  gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  const dpr=window.devicePixelRatio||1, w=canvas.width/dpr, h=canvas.height/dpr;
  const proj=new Float32Array(16), view=new Float32Array(16), mvp=new Float32Array(16);
  m4pers(proj, Math.PI/3, w/h, 0.1, 5000);
  const cx=Math.sin(yaw)*dist*Math.cos(pitch), cy=Math.sin(pitch)*dist, cz=Math.cos(yaw)*dist*Math.cos(pitch);
  const panScale=dist/900; m4look(view, [cx-panX*panScale,cy+panY*panScale,cz], [-panX*panScale,0+panY*panScale,0], [0,1,0]);
  m4mul(mvp, proj, view);

  // edges (brighter) so you see structure
  gl.useProgram(pL);
  gl.bindBuffer(gl.ARRAY_BUFFER, bEdges);
  const aPosL=gl.getAttribLocation(pL,'aPos'); gl.enableVertexAttribArray(aPosL); gl.vertexAttribPointer(aPosL,3,gl.FLOAT,false,0,0);
  gl.uniformMatrix4fv(gl.getUniformLocation(pL,'uMVP'),false,mvp);
  gl.uniform4f(gl.getUniformLocation(pL,'uCol'), 0.36,0.42,0.58, BLOOM.showAll?0.6:0.3);
  gl.drawArrays(gl.LINES,0,E*2);

  // points — draw with DEPTH TEST OFF to guarantee visibility
  gl.disable(gl.DEPTH_TEST);
  gl.useProgram(pP);
  // bind attributes
  gl.bindBuffer(gl.ARRAY_BUFFER, bPos);  let loc=gl.getAttribLocation(pP,'aPos'); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,3,gl.FLOAT,false,0,0);
  gl.bindBuffer(gl.ARRAY_BUFFER, bCol);  loc=gl.getAttribLocation(pP,'aCol'); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,3,gl.FLOAT,false,0,0);
  gl.bindBuffer(gl.ARRAY_BUFFER, bBirth);loc=gl.getAttribLocation(pP,'aBirth');gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,1,gl.FLOAT,false,0,0);
  gl.bindBuffer(gl.ARRAY_BUFFER, bSize); loc=gl.getAttribLocation(pP,'aSize'); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,1,gl.FLOAT,false,0,0);

  gl.uniformMatrix4fv(gl.getUniformLocation(pP,'uMVP'),false,mvp);
  gl.uniform1f(gl.getUniformLocation(pP,'uTime'), BLOOM.showAll? 1e12 : BLOOM.t);
  gl.uniform1f(gl.getUniformLocation(pP,'uRamp'), 420.0);
  gl.uniform1f(gl.getUniformLocation(pP,'uPxScale'), canvas.height/(2*Math.tan(Math.PI/3/2)));
  gl.uniform1f(gl.getUniformLocation(pP,'uForceAll'), BLOOM.showAll?1.0:0.0);
  gl.uniform1f(gl.getUniformLocation(pP,'uYellow'), BLOOM.yellow?1.0:0.0);
  gl.drawArrays(gl.POINTS,0,N);
  gl.enable(gl.DEPTH_TEST);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

/* keys */
document.addEventListener('keydown',e=>{
  if(e.key==='b'||e.key==='B'){
    if(e.shiftKey){ BLOOM.t=0; BLOOM.playing=false; fill.style.width='0%'; setStatus('reset'); }
    else { BLOOM.playing=!BLOOM.playing; setStatus(BLOOM.playing?'playing':'paused'); if(BLOOM.playing) BLOOM.start=performance.now()-BLOOM.t; }
  }
  if(e.key==='g'||e.key==='G'){ BLOOM.showAll=!BLOOM.showAll; setStatus(BLOOM.showAll?'debug: showing all nodes/edges':'debug off'); }
  if(e.key==='y'||e.key==='Y'){ BLOOM.yellow=!BLOOM.yellow; setStatus(BLOOM.yellow?'debug: YELLOW DOTS ON':'yellow off'); }
});

/* mouse wheel note */
setStatus('loading… then try: press Y (yellow) and scroll wheel to adjust zoom; G shows all.');
</script>
</body>
</html>
