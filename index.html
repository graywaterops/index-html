<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Smart Coin® — 3D Donor Dedication Map</title>
<style>
  /* Light theme */
  :root{
    --bg:#ffffff; --panel:#f8fafc; --text:#111827; --muted:#4b5563;
    --border:#e5e7eb;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #app{position:relative;width:100%;height:100vh;min-height:560px}

  #status{
    position:fixed;left:10px;bottom:10px;z-index:10;
    background:var(--panel);color:var(--muted);
    border:1px solid var(--border);border-radius:8px;
    padding:6px 10px;font-size:12px;max-width:80vw;white-space:pre-wrap
  }
  #legend{
    position:fixed;left:10px;top:10px;z-index:10;background:var(--panel);
    border:1px solid var(--border);border-radius:8px;padding:8px 10px;
    font-size:12px;color:#374151
  }
  .chip{display:inline-block;width:10px;height:10px;border-radius:50%;
    margin-right:6px;vertical-align:middle;border:1px solid #cbd5e1}

  /* Controls panel (top-right) */
  #ui{
    position:fixed;right:10px;top:10px;z-index:11;background:var(--panel);
    border:1px solid var(--border);border-radius:8px;padding:10px 12px;
    font-size:12px;color:#111827;min-width:240px;max-width:40ch
  }
  #ui h3{margin:0 0 8px 0;font-size:13px}
  #ui .row{display:flex;align-items:center;gap:8px;margin:8px 0}
  #ui label{width:110px}
  #ui input[type="range"]{flex:1}
  #ui output{width:46px;text-align:right;display:inline-block}
  #ui .btns{display:flex;gap:8px;margin-top:8px}
  #ui button{
    cursor:pointer;border:1px solid var(--border);background:#fff;border-radius:6px;
    padding:6px 10px;font-size:12px
  }
</style>

<!-- Import-map shim (for Safari/older Chromium) -->
<script src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.min.js"></script>

<!-- Import map -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>

<body>
<div id="app"></div>

<div id="legend">
  <div><span class="chip" style="background:#1e3a8a"></span>Dark blue: initial donors</div>
  <div><span class="chip" style="background:#93c5fd"></span>Light blue: each donor’s +1</div>
  <div><span class="chip" style="background:#22c55e"></span>Green: extras (&gt;1)</div>
  <div><span class="chip" style="background:#ef4444"></span>Red: downstream from extras</div>
</div>

<!-- Control panel -->
<div id="ui">
  <h3>Donor Map Controls</h3>
  <div class="row">
    <label for="donors">Initial donors</label>
    <input id="donors" type="range" min="10" max="400" value="80">
    <output id="donorsOut">80</output>
  </div>
  <div class="row">
    <label for="extra">Extra prob.</label>
    <input id="extra" type="range" min="0" max="1" step="0.01" value="0.30">
    <output id="extraOut">0.30</output>
  </div>
  <div class="row">
    <label for="radius">Sphere radius</label>
    <input id="radius" type="range" min="100" max="600" value="260">
    <output id="radiusOut">260</output>
  </div>
  <div class="row">
    <label for="jitter">Child jitter</label>
    <input id="jitter" type="range" min="2" max="60" value="28">
    <output id="jitterOut">28</output>
  </div>
  <div class="row">
    <label for="seed">Seed</label>
    <input id="seed" type="text" placeholder="random" style="flex:1" />
  </div>
  <div class="row">
    <label for="auto">Auto rebuild</label>
    <input id="auto" type="checkbox" checked />
  </div>
  <div class="btns">
    <button id="rebuildBtn" type="button">Rebuild</button>
    <button id="resetViewBtn" type="button">Reset view</button>
  </div>
</div>

<div id="status">Status: loading…</div>

<script type="module">
const statusEl = document.getElementById('status');
const setStatus = (m)=> statusEl.textContent = 'Status: ' + m;
const showError = (e)=>{ setStatus('Error: ' + (e?.message||e)); console.error(e); };

const root = document.getElementById('app');

try {
  setStatus('loading modules…');
  const THREE = await import('three');
  const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');

  // ---- renderer/scene/camera ----
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  root.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff); // white background

  const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 5000);
  function resetView(){
    camera.position.set(0, 0, 600);
    controls.target.set(0, 0, 0);
    controls.update();
  }

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.05;

  scene.add(new THREE.AmbientLight(0xffffff, 0.9));
  const dir = new THREE.DirectionalLight(0xffffff, 0.5); dir.position.set(300,500,400); scene.add(dir);

  function sizeOf(el){
    const w = el.clientWidth || el.parentElement?.clientWidth || window.innerWidth;
    const h = el.clientHeight || el.parentElement?.clientHeight || Math.round(window.innerHeight*0.7);
    return {w: Math.max(1,w), h: Math.max(1,h)};
  }
  function resize(){
    const {w,h} = sizeOf(root);
    camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false);
  }
  window.addEventListener('resize', resize);
  if ('ResizeObserver' in window) new ResizeObserver(resize).observe(root);
  resetView(); resize();

  // ---- interactive state ----
  const state = {
    group:null, nodes:[], links:[], spheres:[], edges:null, glow:null
  };

  // seedable RNG
  function xmur3(str){ for(var i=0,h=1779033703^str.length;i<str.length;i++) h=Math.imul(h^str.charCodeAt(i),3432918353),h=h<<13|h>>>19; return function(){ h=Math.imul(h^ (h>>>16), 2246822507); h=Math.imul(h^ (h>>>13), 3266489909); return (h^ (h>>>16))>>>0; } }
  function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15, t|1); t^=t+Math.imul(t^t>>>7, t|61); return ((t^t>>>14)>>>0)/4294967296; } }
  function makeRNG(seedStr){
    if(!seedStr) return Math.random;
    const seed = xmur3(String(seedStr))();
    return mulberry32(seed);
  }

  // dispose helper
  function dispose(obj){
    obj.traverse(o=>{
      if(o.geometry) o.geometry.dispose();
      if(o.material){
        if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose());
        else o.material.dispose();
      }
    });
  }

  // build / rebuild graph
  function buildGraph(params){
    const {
      initialDonors=80, extraProb=0.3, sphereRadius=260, childJitter=28, seed=''
    } = params;

    // clean previous
    if(state.group){ scene.remove(state.group); dispose(state.group); }
    state.group = new THREE.Group(); scene.add(state.group);
    state.nodes=[]; state.links=[]; state.spheres=[]; state.edges=null;
    if(state.glow){ scene.remove(state.glow); dispose(state.glow); state.glow=null; }

    const rand = makeRNG(seed);

    const COLOR_DARK=0x1e3a8a, COLOR_LIGHT=0x93c5fd, COLOR_GREEN=0x22c55e, COLOR_RED=0xef4444;
    const COLOR_EDGE=0x5b6b95;

    let id=0;
    function addNode(type,parent=null){
      const n={id:id++,type,parent,children:[]}; state.nodes.push(n);
      if(parent!=null){ state.links.push({source:parent,target:n.id}); state.nodes[parent].children.push(n.id); }
      return n;
    }

    // seeds
    for(let i=0;i<initialDonors;i++) addNode('dark', null);

    // each dark -> one light; some -> green + red
    for(let i=0;i<initialDonors;i++){
      const d=i; addNode('light', d);
      if(rand() < extraProb){ const g=addNode('green', d); addNode('red', g.id); }
    }
    // each light -> one more light
    state.nodes.filter(n=>n.type==='light').forEach(l => addNode('light', l.id));

    // place: fibonacci sphere for darks; children near parent
    function fibSphere(n,r=sphereRadius){
      const pts=[], phi=Math.PI*(3-Math.sqrt(5));
      for(let i=0;i<n;i++){
        const y=1-(i/Math.max(1,n-1))*2;
        const rad=Math.sqrt(Math.max(0,1-y*y));
        const th=phi*i;
        pts.push(new THREE.Vector3(Math.cos(th)*rad*r, y*r, Math.sin(th)*rad*r));
      }
      return pts;
    }
    const dark = state.nodes.filter(n=>n.type==='dark'), pts = fibSphere(dark.length, sphereRadius);
    dark.forEach((n,i)=>{ n.x=pts[i].x; n.y=pts[i].y; n.z=pts[i].z; });
    state.nodes.forEach(n=>{
      if(n.type!=='dark'){
        const p = state.nodes.find(x=>x.id===n.parent) || {x:0,y:0,z:0};
        const j = ()=> (rand()*2-1)*childJitter;
        n.x = p.x + j(); n.y = p.y + j(); n.z = p.z + j();
      }
    });

    // draw nodes
    const col = (t)=> t==='dark'?COLOR_DARK : t==='light'?COLOR_LIGHT : t==='green'?COLOR_GREEN : COLOR_RED;
    state.nodes.forEach(n=>{
      const size = n.type==='dark'?5.2 : n.type==='light'?4 : n.type==='green'?4.4 : 3.8;
      const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(size,18,18),
        new THREE.MeshStandardMaterial({color:col(n.type),metalness:0.15,roughness:0.45})
      );
      mesh.position.set(n.x,n.y,n.z); mesh.userData.id=n.id;
      state.group.add(mesh); state.spheres.push(mesh);
    });

    // draw edges
    const pos = new Float32Array(state.links.length*6); let k=0;
    state.links.forEach(l=>{
      const s=state.nodes.find(n=>n.id===l.source), t=state.nodes.find(n=>n.id===l.target);
      pos[k++]=s.x; pos[k++]=s.y; pos[k++]=s.z; pos[k++]=t.x; pos[k++]=t.y; pos[k++]=t.z;
    });
    const edgeGeo=new THREE.BufferGeometry(); edgeGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    state.edges=new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({color:COLOR_EDGE,transparent:true,opacity:0.35}));
    state.group.add(state.edges);
  }

  // highlight logic (uses current state)
  let dragging=false;
  controls.addEventListener('start', ()=> dragging=true);
  controls.addEventListener('end', ()=> dragging=false);

  const ray=new THREE.Raycaster(), mouse=new THREE.Vector2();
  function clearHi(){
    if(state.glow){ state.group.remove(state.glow); dispose(state.glow); state.glow=null; }
    state.spheres.forEach(m=>{ m.material.transparent=false; m.material.opacity=1; });
    if(state.edges) state.edges.material.opacity=0.35;
  }
  function highlight(startId){
    clearHi();
    const keep=new Set([startId]), q=[startId];
    while(q.length){
      const cur=q.shift();
      state.links.filter(l=>l.source===cur).forEach(l=>{
        if(!keep.has(l.target)){ keep.add(l.target); q.push(l.target); }
      });
    }
    state.spheres.forEach(m=>{
      const on=keep.has(m.userData.id); m.material.transparent=true; m.material.opacity=on?1:0.12;
    });
    if(state.edges) state.edges.material.opacity=0.08;

    const kept=state.links.filter(l=> keep.has(l.source)&&keep.has(l.target));
    const gpos=new Float32Array(kept.length*6); let i=0;
    kept.forEach(l=>{
      const s=state.nodes.find(n=>n.id===l.source), t=state.nodes.find(n=>n.id===l.target);
      gpos[i++]=s.x; gpos[i++]=s.y; gpos[i++]=s.z; gpos[i++]=t.x; gpos[i++]=t.y; gpos[i++]=t.z;
    });
    const ggeo=new THREE.BufferGeometry(); ggeo.setAttribute('position', new THREE.BufferAttribute(gpos,3));
    state.glow=new THREE.LineSegments(ggeo, new THREE.LineBasicMaterial({color:0x06b6d4, transparent:true, opacity:0.95}));
    state.group.add(state.glow);
  }
  function onPointer(ev){
    if(dragging) return; // don't click-select after a drag
    const rect=renderer.domElement.getBoundingClientRect();
    const px=(ev.clientX-rect.left)/rect.width;
    const py=(ev.clientY-rect.top)/rect.height;
    mouse.x=px*2-1; mouse.y=-(py*2-1);
    ray.setFromCamera(mouse,camera);
    const hits=ray.intersectObjects(state.spheres,true);
    if(hits.length){ highlight(hits[0].object.userData.id); } else { clearHi(); }
  }
  renderer.domElement.addEventListener('pointerup', onPointer, {passive:true});

  // animation loop
  function loop(){ controls.update(); renderer.render(scene,camera); requestAnimationFrame(loop); }
  loop();

  // ---- UI wiring ----
  const $ = (id)=> document.getElementById(id);
  const donors=$('donors'), donorsOut=$('donorsOut');
  const extra=$('extra'), extraOut=$('extraOut');
  const radius=$('radius'), radiusOut=$('radiusOut');
  const jitter=$('jitter'), jitterOut=$('jitterOut');
  const seed=$('seed'), auto=$('auto');
  const rebuildBtn=$('rebuildBtn'), resetViewBtn=$('resetViewBtn');

  function syncOutputs(){
    donorsOut.textContent=donors.value;
    extraOut.textContent=Number(extra.value).toFixed(2);
    radiusOut.textContent=radius.value;
    jitterOut.textContent=jitter.value;
  }
  function getParams(){
    return {
      initialDonors: parseInt(donors.value,10),
      extraProb: Math.max(0, Math.min(1, parseFloat(extra.value))),
      sphereRadius: parseInt(radius.value,10),
      childJitter: parseInt(jitter.value,10),
      seed: (seed.value || '').trim()
    };
  }

  let debounceTimer=null;
  function scheduleRebuild(){
    if(!auto.checked) return;
    clearTimeout(debounceTimer);
    debounceTimer=setTimeout(()=>{ setStatus('rebuilding…'); buildGraph(getParams()); setStatus('donor map ready — rotate/zoom, tap/click to highlight'); }, 200);
  }

  [donors,extra,radius,jitter,seed].forEach(el=>{
    el.addEventListener('input', ()=>{ syncOutputs(); scheduleRebuild(); });
    el.addEventListener('change', ()=>{ syncOutputs(); scheduleRebuild(); });
  });
  rebuildBtn.addEventListener('click', ()=>{
    setStatus('rebuilding…'); buildGraph(getParams());
    setStatus('donor map ready — rotate/zoom, tap/click to highlight');
  });
  resetViewBtn.addEventListener('click', ()=> resetView());

  // initial build
  syncOutputs();
  buildGraph(getParams());
  setStatus('donor map ready — rotate/zoom, tap/click to highlight');

} catch(err) {
  showError(err);
}
</script>
</body>
</html>
