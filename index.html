<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Smart Coin™ — Donor Universe 3D (Influence + KPIs + CSV)</title>
<style>
  :root{ --bg:#000; --panel:#111826; --text:#eaf0ff; --muted:#9aa3c9; --border:#1f2a4d; --accent:#6ee7ff; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #app{position:relative;width:100%;height:100vh;min-height:560px;background:#000;overflow:hidden}
  canvas#gl{position:absolute; inset:0; width:100%; height:100%; display:block}

  /* UI */
  #legend{position:fixed;left:10px;top:10px;z-index:10;background:var(--panel);
    border:1px solid var(--border);border-radius:8px;padding:6px 8px;font-size:12px;color:#cfe1ff;opacity:.92}
  .chip{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;border:1px solid #2f3b66}

  #status{position:fixed;left:10px;bottom:10px;z-index:10;background:var(--panel);color:var(--muted);
    border:1px solid var(--border);border-radius:8px;padding:6px 10px;font-size:12px;max-width:78vw;white-space:pre-wrap}

  #counters{position:fixed;left:50%;top:10px;transform:translateX(-50%);z-index:10;display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
  .pill{background:var(--panel);border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:13px;opacity:.96}
  .pill b{font-weight:700}

  #kpis{position:fixed;left:50%;top:48px;transform:translateX(-50%);z-index:10;display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
  .k{background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:4px 8px;font-size:12px;color:#d9e4ff;opacity:.96}

  #buttons{position:fixed;right:10px;top:10px;z-index:10;display:flex;gap:8px}
  .btn{background:var(--panel);color:#eaf0ff;border:1px solid var(--border);border-radius:999px;padding:8px 10px;font-size:12px;cursor:pointer}

  #help{position:fixed;right:10px;top:48px;z-index:10;background:var(--panel);border:1px solid var(--border);
    border-radius:10px;padding:10px 12px;font-size:12px;display:none;max-width:360px}
  #help.open{display:block}

  #timeline{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);z-index:10;width:min(520px,70vw);height:8px;
    background:var(--panel);border:1px solid var(--border);border-radius:999px;overflow:hidden;box-shadow:0 2px 10px rgba(0,0,0,.25)}
  #tlFill{height:100%;width:0%;background:var(--accent);opacity:.95}

  #tip{position:fixed;pointer-events:none;z-index:11;background:#0b1020;border:1px solid #223054;border-radius:6px;
    padding:6px 8px;font-size:12px;display:none;color:#dce6ff}

  @media (max-width:768px){ #counters{top:auto;bottom:46px} #kpis{top:auto;bottom:16px} }
</style>
</head>
<body>
<div id="app"><canvas id="gl"></canvas></div>

<div id="legend">
  <div><span class="chip" style="background:#1e3a8a"></span>Dark blue: roots</div>
  <div><span class="chip" style="background:#93c5fd"></span>Light blue: primary +1 (max 1 per parent)</div>
  <div><span class="chip" style="background:#22c55e"></span>Green: extras (other donations)</div>
  <div><span class="chip" style="background:#ef4444"></span>Red: everything below any green</div>
</div>

<div id="counters">
  <div class="pill">Coins: <b id="coinsVal">0</b></div>
  <div class="pill">Raised: <b id="raisedVal">$0</b></div>
</div>

<div id="kpis">
  <div class="k">Roots <b id="kRoots">0</b></div>
  <div class="k">Donors <b id="kDonors">0</b></div>
  <div class="k">Light edges <b id="kLight">0</b></div>
  <div class="k">Extras <b id="kExtras">0</b></div>
  <div class="k">Extras rate <b id="kExRate">0%</b></div>
  <div class="k">Avg depth <b id="kDepth">0.0</b></div>
  <div class="k">Rₚ <b id="kRp">0.00</b></div>
  <div class="k">Rₑ <b id="kRe">0.00</b></div>
</div>

<div id="buttons">
  <button id="btnBloom" class="btn">⏸ Bloom</button>
  <button id="btnExport" class="btn">⬇ Export CSV</button>
  <button id="btnHelp" class="btn">?</button>
</div>

<div id="help">
  <b>Controls</b><br>
  • Left-drag: rotate · Right/Ctrl-drag: pan · Wheel: zoom<br>
  • Click a node to highlight its constellation + influence so far<br>
  • B = play/pause · Shift+B = restart · H = toggle help<br><br>
  <i>Size = influence</i> (coins+gifts visible so far). KPIs update during Bloom.<br>
  Export CSV for your HU CIE case study.
</div>

<div id="timeline"><div id="tlFill"></div></div>
<div id="tip"></div>
<div id="status">Status: loading…</div>

<script>
/*** ---------- Small utilities ---------- ***/
const $=(id)=>document.getElementById(id);
const statusEl=$('status'), tipEl=$('tip'), tlFill=$('tlFill');
const coinsVal=$('coinsVal'), raisedVal=$('raisedVal');
const kRoots=$('kRoots'), kDonors=$('kDonors'), kLight=$('kLight'), kExtras=$('kExtras'),
      kExRate=$('kExRate'), kDepth=$('kDepth'), kRp=$('kRp'), kRe=$('kRe');
const fmtMoney=(n)=>n.toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
const setStatus=(m)=>statusEl.textContent='Status: '+m;
const easeOutCubic=t=>1-Math.pow(1-Math.min(1,Math.max(0,t)),3);
function xmur3(str){for(var i=0,h=1779033703^str.length;i<str.length;i++)h=Math.imul(h^str.charCodeAt(i),3432918353),h=h<<13|h>>>19;return function(){h=Math.imul(h^(h>>>16),2246822507);h=Math.imul(h^(h>>>13),3266489909);return(h^(h>>>16))>>>0}}
function mulberry32(a){return function(){var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return((t^t>>>14)>>>0)/4294967296}}
function makeRNG(s){if(!s) return Math.random; const seed=xmur3(String(s))(); return mulberry32(seed)}
function roundTo(v,step){return Math.round(v/step)*step}
function poisson(lambda,rand){if(lambda<=0)return 0; const L=Math.exp(-lambda); let k=0,p=1; do{k++;p*=rand()}while(p>L); return k-1}
function sampleGift(rand){const u=rand(); if(u<0.60) return 50; if(u<0.78) return roundTo(50+rand()*100,5); if(u<0.90) return roundTo(150+rand()*350,10); if(u<0.98) return roundTo(500+rand()*1500,25); return roundTo(2000+rand()*3000,50);}

/*** ---------- Model parameters ---------- ***/
const P={ roots:250,
  lightDepth:10, lightProb:.85, lightFan:1.5, lightDecay:.90,
  extraDepth:9,  extraProb:.85, extraFan:1.8, extraDecay:.88,
  radius:800, jitter:36, cap:20000, seed:'universe-250-webgl-pro'
};

/*** ---------- Build donor graph (one-light-per-parent) ---------- ***/
function buildGraph(P){
  const rand=makeRNG(P.seed), randJ=makeRNG(P.seed+'j'), randG=makeRNG(P.seed+'g');
  const ROOT_STAGGER=140, STEP_LIGHT=560, STEP_GREEN=420, STEP_RED=300;
  const nodes=[], links=[], roots=[];
  let id=0;
  function addNode(type,parent=null,branch='light',bdepth=0,birth=0){
    if(nodes.length>=P.cap) return null;
    const gift=sampleGift(randG);
    const n={id:id++,type,parent,children:[],branch,bdepth,birth,gift,x:0,y:0,z:0};
    nodes.push(n);
    if(parent!=null){links.push({source:parent,target:n.id}); nodes[parent].children.push(n.id);}
    return n;
  }
  for(let i=0;i<P.roots;i++){const b=i*ROOT_STAGGER+rand()*80; const r=addNode('dark',null,'light',0,b); if(r) roots.push(r.id);}
  const q=roots.map(id=>({id}));
  while(q.length && nodes.length<P.cap){
    const pid=q.shift().id; const p=nodes[pid];
    if(p.branch==='light' && p.bdepth<P.lightDepth){
      const scale=Math.pow(P.lightDecay, Math.max(0,p.bdepth));
      if(rand()<P.lightProb*scale){
        let k=poisson(Math.max(0,P.lightFan*scale), rand);
        if(k>0){
          const lb=p.birth+STEP_LIGHT*(0.8+0.4*rand());
          const c=addNode('light',pid,'light',p.bdepth+1,lb); if(c) q.push({id:c.id});
          for(let i=1;i<k;i++){
            const gb=p.birth+STEP_GREEN*(0.65+0.5*rand());
            const g=addNode('green',pid,'extra',1,gb); if(g) q.push({id:g.id});
          }
        }
      }
    } else if(p.branch==='extra' && p.bdepth<P.extraDepth){
      const scale=Math.pow(P.extraDecay, Math.max(0,p.bdepth-1));
      if(rand()<P.extraProb*scale){
        let k=poisson(Math.max(0,P.extraFan*scale), rand);
        for(let i=0;i<k;i++){
          const rb=p.birth+STEP_RED*(0.6+0.5*rand());
          const r=addNode('red',pid,'extra',p.bdepth+1,rb); if(r) q.push({id:r.id});
        }
      }
    }
  }
  function fibSphere(n,r=P.radius){const pts=[],phi=Math.PI*(3-Math.sqrt(5));
    for(let i=0;i<n;i++){const y=1-(i/Math.max(1,n-1))*2; const rad=Math.sqrt(Math.max(0,1-y*y)); const th=phi*i;
      pts.push({x:Math.cos(th)*rad*r,y:y*r,z:Math.sin(th)*rad*r});}
    return pts;
  }
  const rootsObjs=nodes.filter(n=>n.type==='dark'), pts=fibSphere(rootsObjs.length,P.radius);
  rootsObjs.forEach((n,i)=>{n.x=pts[i].x; n.y=pts[i].y; n.z=pts[i].z;});
  nodes.forEach(n=>{
    if(n.type!=='dark'){
      const p=nodes[n.parent]||{x:0,y:0,z:0};
      const spread=P.jitter*(1+0.04*Math.max(0,n.bdepth-1));
      const j=()=> (randJ()*2-1)*spread;
      n.x=p.x+j(); n.y=p.y+j(); n.z=p.z+j();
    }
  });

  // births/gifts prefix
  const byBirth=nodes.slice().sort((a,b)=>a.birth-b.birth);
  const birthsSorted=byBirth.map(n=>n.birth);
  let acc=0; const giftPrefix=byBirth.map(n=>{ acc+=n.gift; return acc; });
  const maxBirth=nodes.reduce((m,n)=>Math.max(m,n.birth),0);

  return {nodes,links,roots,birthsSorted,giftPrefix,maxBirth,byBirth};
}

/*** ---------- Minimal mat4 utils ---------- ***/
function mat4Perspective(out, fovy, aspect, near, far){
  const f=1/Math.tan(fovy/2), nf=1/(near-far);
  out[0]=f/aspect; out[1]=0; out[2]=0; out[3]=0;
  out[4]=0; out[5]=f; out[6]=0; out[7]=0;
  out[8]=0; out[9]=0; out[10]=(far+near)*nf; out[11]=-1;
  out[12]=0; out[13]=0; out[14]=2*far*near*nf; out[15]=0; return out;
}
function mat4Look(out, eye, center, up){
  const [ex,ey,ez]=eye, [cx,cy,cz]=center, [ux,uy,uz]=up;
  let zx=ex-cx, zy=ey-cy, zz=ez-cz; let zl=1/Math.hypot(zx,zy,zz); zx*=zl; zy*=zl; zz*=zl;
  let xx=uy*zz-uz*zy, xy=uz*zx-ux*zz, xz=ux*zy-uy*zx; let xl=1/Math.hypot(xx,xy,xz); xx*=xl; xy*=xl; xz*=xl;
  let yx=zy*xz-zz*xy, yy=zz*xx-zx*xz, yz=zx*xy-zy*xx;
  out[0]=xx; out[1]=yx; out[2]=zx; out[3]=0;
  out[4]=xy; out[5]=yy; out[6]=zy; out[7]=0;
  out[8]=xz; out[9]=yz; out[10]=zz; out[11]=0;
  out[12]=-(xx*ex+xy*ey+xz*ez);
  out[13]=-(yx*ex+yy*ey+yz*ez);
  out[14]=-(zx*ex+zy*ey+zz*ez);
  out[15]=1; return out;
}
function mat4Mul(out,a,b){
  const o=new Float32Array(16);
  for(let r=0;r<4;r++) for(let c=0;c<4;c++){
    o[r*4+c]=a[r*4+0]*b[0*4+c]+a[r*4+1]*b[1*4+c]+a[r*4+2]*b[2*4+c]+a[r*4+3]*b[3*4+c];
  }
  out.set(o); return out;
}

/*** ---------- WebGL setup ---------- ***/
const canvas=document.getElementById('gl');
const gl = canvas.getContext('webgl', {antialias:true, alpha:false});
if(!gl){ setStatus('Error: WebGL not available'); throw new Error('WebGL not available'); }
function resizeGL(){
  const dpr=window.devicePixelRatio||1;
  const w=canvas.clientWidth, h=canvas.clientHeight;
  canvas.width=Math.max(1, w*dpr); canvas.height=Math.max(1, h*dpr);
  gl.viewport(0,0,canvas.width,canvas.height);
}
window.addEventListener('resize', resizeGL);

/*** ---------- Shaders ---------- ***/
// Points with per-vertex size attribute (dynamic, updated each frame)
const vsPoints = `
attribute vec3 aPos;
attribute vec3 aCol;
attribute float aBirth;
attribute float aSize;      // px at clip.w == 1
uniform mat4 uMVP;
uniform float uTime;
uniform float uRamp;
uniform float uPxScale;     // pixel scale factor
varying vec3 vCol;
varying float vAlpha;
void main(){
  vec4 clip = uMVP * vec4(aPos,1.0);
  gl_Position = clip;
  float a = clamp( (uTime - aBirth) / uRamp, 0.0, 1.0 );
  vAlpha = a;
  vCol = aCol;
  float ps = uPxScale / max(0.0001, clip.w);
  gl_PointSize = aSize * ps * a;  // influence-scaled + bloom alpha
}
`;
const fsPoints = `
precision mediump float;
varying vec3 vCol;
varying float vAlpha;
void main(){
  vec2 uv = gl_PointCoord*2.0 - 1.0;
  float r2 = dot(uv,uv);
  if(r2>1.0) discard;
  float edge = smoothstep(1.0, 0.7, 1.0 - r2);
  gl_FragColor = vec4(vCol, vAlpha * edge);
}
`;
const vsLines = `attribute vec3 aPos; uniform mat4 uMVP; void main(){ gl_Position = uMVP * vec4(aPos,1.0); }`;
const fsLines = `precision mediump float; uniform vec4 uColor; void main(){ gl_FragColor = uColor; }`;

function compile(type, src){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
function program(vsSrc, fsSrc){ const p=gl.createProgram(); gl.attachShader(p,compile(gl.VERTEX_SHADER,vsSrc)); gl.attachShader(p,compile(gl.FRAGMENT_SHADER,fsSrc)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; }
const progPoints=program(vsPoints,fsPoints), progLines=program(vsLines,fsLines);

/*** ---------- Model & buffers ---------- ***/
const model = buildGraph(P);
const N=model.nodes.length, E=model.links.length;

const COLOR_DARK=[0x1e/255,0x3a/255,0x8a/255], COLOR_LIGHT=[0x93/255,0xc5/255,0xfd/255],
      COLOR_GREEN=[0x22/255,0xc5/255,0x5e/255], COLOR_RED=[0xef/255,0x44/255,0x44/255];

const nodePos=new Float32Array(N*3), nodeCol=new Float32Array(N*3), nodeBirth=new Float32Array(N);
for(let i=0;i<N;i++){
  const n=model.nodes[i]; nodePos[i*3]=n.x; nodePos[i*3+1]=n.y; nodePos[i*3+2]=n.z;
  const c=n.type==='dark'?COLOR_DARK:n.type==='light'?COLOR_LIGHT:n.type==='green'?COLOR_GREEN:COLOR_RED;
  nodeCol[i*3]=c[0]; nodeCol[i*3+1]=c[1]; nodeCol[i*3+2]=c[2]; nodeBirth[i]=n.birth;
}
// static edges
const edgePos=new Float32Array(E*6);
for(let i=0;i<E;i++){ const l=model.links[i], a=model.nodes[l.source], b=model.nodes[l.target];
  edgePos.set([a.x,a.y,a.z,b.x,b.y,b.z], i*6);
}
// growth edges sorted by child birth
const sorted=model.links.slice().sort((a,b)=> model.nodes[a.target].birth - model.nodes[b.target].birth);
const edgeGrowPos=new Float32Array(E*6), edgeGrowBirths=new Float32Array(E);
for(let i=0;i<E;i++){ const l=sorted[i], a=model.nodes[l.source], b=model.nodes[l.target];
  edgeGrowPos.set([a.x,a.y,a.z,b.x,b.y,b.z], i*6); edgeGrowBirths[i]=model.nodes[l.target].birth;
}

// GL buffers
function mkBuf(target,data){const b=gl.createBuffer(); gl.bindBuffer(target,b); gl.bufferData(target,data,gl.STATIC_DRAW); return b;}
const bufPos=mkBuf(gl.ARRAY_BUFFER,nodePos), bufCol=mkBuf(gl.ARRAY_BUFFER,nodeCol),
      bufBirth=mkBuf(gl.ARRAY_BUFFER,nodeBirth), bufEdges=mkBuf(gl.ARRAY_BUFFER,edgePos),
      bufGrow=mkBuf(gl.ARRAY_BUFFER,edgeGrowPos);

// dynamic size buffer (influence-scaled)
const nodeSize=new Float32Array(N); // px base for each node (updated each frame)
const bufSize=gl.createBuffer();

// Controls
let yaw=0,pitch=0,dist=1100,panX=0,panY=0,drag=false,rot=false,lastX=0,lastY=0;
canvas.addEventListener('mousedown',e=>{drag=true; rot=(e.button===0 && !e.ctrlKey); lastX=e.clientX; lastY=e.clientY;});
window.addEventListener('mouseup',()=>drag=false);
window.addEventListener('mousemove',e=>{
  if(!drag) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
  if(rot){ yaw += dx*0.005; pitch=Math.max(-1.2,Math.min(1.2,pitch+dy*0.005)); }
  else { panX += dx; panY += dy; }
});
canvas.addEventListener('wheel',e=>{ e.preventDefault(); dist=Math.max(200,Math.min(3000,dist+e.deltaY)); }, {passive:false});

// MVP matrices
const matProj=new Float32Array(16), matView=new Float32Array(16), matMVP=new Float32Array(16);

// Bloom clock
const BLOOM={playing:true,t:0,duration:model.maxBirth+2000,start:performance.now()};

// influence accumulators (recomputed each frame for visible prefix)
const subCoins=new Uint32Array(N), subGifts=new Float64Array(N); // subtree counts for visible nodes
const visibleMask=new Uint8Array(N);

// metrics helpers
function upperBound(arr,val){let lo=0,hi=arr.length; while(lo<hi){const mid=(lo+hi)>>1; if(arr[mid]<=val) lo=mid+1; else hi=mid;} return lo;}

function recomputeInfluenceAndKPIs(){
  // visible prefix by birth
  const k=upperBound(model.birthsSorted, BLOOM.t);
  // reset
  visibleMask.fill(0); subCoins.fill(0); subGifts.fill(0);
  for(let i=0;i<k;i++){ const id=model.byBirth[i].id; visibleMask[id]=1; subCoins[id]=1; subGifts[id]=model.nodes[id].gift; }

  // post-order accumulation (reverse birth order ensures children first)
  for(let i=k-1;i>=0;i--){
    const id=model.byBirth[i].id;
    const n=model.nodes[id];
    if(n.parent!=null && visibleMask[n.parent]){
      subCoins[n.parent]+=subCoins[id];
      subGifts[n.parent]+=subGifts[id];
    }
  }

  // dynamic size: base by type + influence
  // base px radii: dark 5.2, light 4.0, green 4.4, red 3.8
  function baseSizeOf(t){return t==='dark'?5.2 : t==='light'?4.0 : t==='green'?4.4 : 3.8;}
  // influence -> size boost: log1p of raised (coins*50 + gifts), mapped to [0 .. 14] px
  for(let i=0;i<N;i++){
    if(!visibleMask[i]){ nodeSize[i]=0.01; continue; }
    const raised = subCoins[i]*50 + subGifts[i];
    const boost = Math.min(14, Math.log1p(raised)/Math.log(1+5000) * 14); // 0..14px
    nodeSize[i] = baseSizeOf(model.nodes[i].type) + boost;
  }
  // upload size buffer
  gl.bindBuffer(gl.ARRAY_BUFFER, bufSize);
  gl.bufferData(gl.ARRAY_BUFFER, nodeSize, gl.DYNAMIC_DRAW);

  // KPIs
  const rootsVisible = model.roots.filter(r=>visibleMask[r]).length;
  const donorsVisible = k;
  let lightEdges=0, extras=0, parentsLight=0, parentsAny=0, sumDepth=0, depthCount=0, parentsWithExtra=0;

  for(let i=0;i<N;i++){
    if(!visibleMask[i]) continue;
    const n=model.nodes[i];
    sumDepth += n.bdepth; depthCount++;
    if(n.children.length>0) parentsAny++;
    if(n.branch==='light') parentsLight++;

    for(const ch of n.children){
      if(!visibleMask[ch]) continue;
      const t=model.nodes[ch].type;
      if(t==='light') lightEdges++;
      if(t==='green') { extras++; parentsWithExtra++; } // count parent occurrence once later
    }
  }
  // parents with extra: count unique
  if(extras>0){
    const seen=new Set();
    for(let i=0;i<N;i++){
      if(!visibleMask[i]) continue;
      const n=model.nodes[i];
      if(n.children.some(ch=> visibleMask[ch] && model.nodes[ch].type==='green')) seen.add(i);
    }
    parentsWithExtra = seen.size;
  }

  const Rp = parentsLight>0 ? lightEdges/parentsLight : 0;
  const Re = parentsAny>0 ? extras/parentsAny : 0;
  const exRate = parentsAny>0 ? parentsWithExtra/parentsAny : 0;
  const avgDepth = depthCount>0 ? (sumDepth/depthCount) : 0;

  // set UI
  kRoots.textContent = rootsVisible.toLocaleString('en-US');
  kDonors.textContent = donorsVisible.toLocaleString('en-US');
  kLight.textContent = lightEdges.toLocaleString('en-US');
  kExtras.textContent = extras.toLocaleString('en-US');
  kExRate.textContent = (exRate*100).toFixed(0)+'%';
  kDepth.textContent = avgDepth.toFixed(1);
  kRp.textContent = Rp.toFixed(2);
  kRe.textContent = Re.toFixed(2);

  // counters strip (coins/raised already done elsewhere)
}

function updateCounters(){
  const idx=upperBound(model.birthsSorted, BLOOM.t);
  const coins=idx;
  const gifts= idx? model.giftPrefix[idx-1] : 0;
  const raised = coins*50 + gifts;
  coinsVal.textContent = coins.toLocaleString('en-US');
  raisedVal.textContent = fmtMoney(Math.round(raised));
}

/*** ---------- Picking (CPU project) ---------- ***/
function projectPoint(x,y,z, mvp, width, height){
  const v=[x,y,z,1], o=[0,0,0,0];
  for(let r=0;r<4;r++) o[r]=mvp[r*4+0]*v[0]+mvp[r*4+1]*v[1]+mvp[r*4+2]*v[2]+mvp[r*4+3]*v[3];
  const iw = 1/Math.max(1e-6, o[3]);
  const ndcX=o[0]*iw, ndcY=o[1]*iw;
  return {x:(ndcX*0.5+0.5)*width, y:(-ndcY*0.5+0.5)*height};
}
let highlightSet=null;

/*** ---------- Render loop ---------- ***/
function render(){
  if(BLOOM.playing){
    BLOOM.t = Math.min(BLOOM.duration, performance.now()-BLOOM.start);
    if(BLOOM.t>=BLOOM.duration){ BLOOM.playing=false; $('btnBloom').textContent='⏵ Bloom'; }
  }
  updateCounters();
  recomputeInfluenceAndKPIs();
  tlFill.style.width = `${Math.min(100,(BLOOM.t/BLOOM.duration)*100)}%`;

  resizeGL();
  gl.enable(gl.DEPTH_TEST);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const dpr=window.devicePixelRatio||1, w=canvas.width/dpr, h=canvas.height/dpr;
  const matProj=new Float32Array(16), matView=new Float32Array(16), matMVP=new Float32Array(16);
  mat4Perspective(matProj, Math.PI/3, w/h, 0.1, 5000);
  const cx=Math.sin(yaw)*dist*Math.cos(pitch), cy=Math.sin(pitch)*dist, cz=Math.cos(yaw)*dist*Math.cos(pitch);
  const panScale=dist/900;
  mat4Look(matView, [cx - panX*panScale, cy + panY*panScale, cz], [ -panX*panScale, 0+panY*panScale, 0 ], [0,1,0]);
  mat4Mul(matMVP, matProj, matView);

  // base edges faint
  gl.useProgram(progLines);
  gl.bindBuffer(gl.ARRAY_BUFFER, bufEdges);
  const aPosL=gl.getAttribLocation(progLines,'aPos'); gl.enableVertexAttribArray(aPosL);
  gl.vertexAttribPointer(aPosL,3,gl.FLOAT,false,0,0);
  gl.uniformMatrix4fv(gl.getUniformLocation(progLines,'uMVP'),false,matMVP);
  gl.uniform4f(gl.getUniformLocation(progLines,'uColor'), 0x5b/255,0x6b/255,0x95/255, 0.14);
  gl.drawArrays(gl.LINES,0,E*2);

  // growing cyan edges
  let lo=0, hi=edgeGrowBirths.length; while(lo<hi){const mid=(lo+hi)>>1; if(edgeGrowBirths[mid]<=BLOOM.t) lo=mid+1; else hi=mid;}
  const segs=lo;
  if(segs>0){
    gl.bindBuffer(gl.ARRAY_BUFFER, bufGrow);
    gl.vertexAttribPointer(aPosL,3,gl.FLOAT,false,0,0);
    gl.uniform4f(gl.getUniformLocation(progLines,'uColor'), 110/255,231/255,255/255, 0.95);
    gl.drawArrays(gl.LINES,0,segs*2);
  }

  // points (with dynamic sizes)
  gl.useProgram(progPoints);
  // pos
  gl.bindBuffer(gl.ARRAY_BUFFER, bufPos);
  const aPos=gl.getAttribLocation(progPoints,'aPos'); gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0);
  // col
  gl.bindBuffer(gl.ARRAY_BUFFER, bufCol);
  const aCol=gl.getAttribLocation(progPoints,'aCol'); gl.enableVertexAttribArray(aCol);
  gl.vertexAttribPointer(aCol,3,gl.FLOAT,false,0,0);
  // birth
  gl.bindBuffer(gl.ARRAY_BUFFER, bufBirth);
  const aBirth=gl.getAttribLocation(progPoints,'aBirth'); gl.enableVertexAttribArray(aBirth);
  gl.vertexAttribPointer(aBirth,1,gl.FLOAT,false,0,0);
  // dynamic size
  gl.bindBuffer(gl.ARRAY_BUFFER, bufSize);
  const aSize=gl.getAttribLocation(progPoints,'aSize'); gl.enableVertexAttribArray(aSize);
  gl.vertexAttribPointer(aSize,1,gl.FLOAT,false,0,0);

  gl.uniformMatrix4fv(gl.getUniformLocation(progPoints,'uMVP'),false,matMVP);
  gl.uniform1f(gl.getUniformLocation(progPoints,'uTime'), BLOOM.t);
  gl.uniform1f(gl.getUniformLocation(progPoints,'uRamp'), 420.0);
  gl.uniform1f(gl.getUniformLocation(progPoints,'uPxScale'), canvas.height/Math.tan(Math.PI/3/2)); // pixel scale

  gl.drawArrays(gl.POINTS,0,N);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

/*** ---------- Picking handler (click) ---------- ***/
canvas.addEventListener('click', (e)=>{
  const dpr=window.devicePixelRatio||1, w=canvas.width/dpr, h=canvas.height/dpr;
  const matProj=new Float32Array(16), matView=new Float32Array(16), matMVP=new Float32Array(16);
  mat4Perspective(matProj, Math.PI/3, w/h, 0.1, 5000);
  const cx=Math.sin(yaw)*dist*Math.cos(pitch), cy=Math.sin(pitch)*dist, cz=Math.cos(yaw)*dist*Math.cos(pitch);
  const panScale=dist/900;
  mat4Look(matView, [cx - panX*panScale, cy + panY*panScale, cz], [ -panX*panScale, 0+panY*panScale, 0 ], [0,1,0]);
  mat4Mul(matMVP, matProj, matView);

  const mx=e.clientX, my=e.clientY;
  let best=-1, bestD=14;
  for(let i=0;i<N;i++){
    if(!visibleMask[i]) continue;
    const n=model.nodes[i];
    const p=projectPoint(n.x,n.y,n.z,matMVP,w,h);
    const d=Math.hypot(mx-p.x,my-p.y);
    if(d<bestD){ bestD=d; best=i; }
  }
  if(best>=0){
    const keep=new Set([best]), q=[best];
    while(q.length){const cur=q.shift(); model.nodes[cur].children.forEach(ch=>{ if(visibleMask[ch] && !keep.has(ch)){ keep.add(ch); q.push(ch);} });}
    // influence so far
    let coins=0,gifts=0;
    keep.forEach(id=>{ coins+=1; gifts+=model.nodes[id].gift; });
    const raised=coins*50 + gifts;
    const selfGift=model.nodes[best].gift + 50, network=raised-selfGift;
    setStatus(`selected #${best} — direct ${fmtMoney(selfGift)} · constellation ${coins-1} others raising ${fmtMoney(network)} (total ${fmtMoney(raised)})`);
  }
});

/*** ---------- Buttons / keys ---------- ***/
$('btnHelp').addEventListener('click',()=> $('help').classList.toggle('open'));
$('btnBloom').addEventListener('click',()=>{
  BLOOM.playing=!BLOOM.playing;
  $('btnBloom').textContent=BLOOM.playing?'⏸ Bloom':'⏵ Bloom';
  if(BLOOM.playing) BLOOM.start=performance.now()-BLOOM.t;
});
window.addEventListener('keydown',e=>{
  if(e.key==='h'||e.key==='H') $('help').classList.toggle('open');
  if(e.key==='b'||e.key==='B'){
    if(e.shiftKey){ BLOOM.t=0; BLOOM.playing=false; $('btnBloom').textContent='⏵ Bloom'; tlFill.style.width='0%'; }
    else { BLOOM.playing=!BLOOM.playing; $('btnBloom').textContent=BLOOM.playing?'⏸ Bloom':'⏵ Bloom'; if(BLOOM.playing) BLOOM.start=performance.now()-BLOOM.t; }
  }
});

/*** ---------- CSV Export ---------- ***/
function exportCSV(){
  // compute current visible mask/influence once more to ensure consistency
  recomputeInfluenceAndKPIs();
  const rows=[];
  rows.push(['id','type','branch','parent','birth_ms','bdepth','gift_usd','subtree_coins','subtree_gifts','raised_self','raised_subtree']);
  for(let i=0;i<N;i++){
    if(!visibleMask[i]) continue;
    const n=model.nodes[i];
    const raisedSelf = n.gift + 50;
    const raisedSub = subCoins[i]*50 + subGifts[i];
    rows.push([n.id,n.type,n.branch,(n.parent==null?''+null:n.parent),n.birth,n.bdepth,Math.round(n.gift),subCoins[i],Math.round(subGifts[i]),Math.round(raisedSelf),Math.round(raisedSub)]);
  }
  const csv = rows.map(r=>r.map(x=>String(x).includes(',')?`"${String(x).replaceAll('"','""')}"`:x).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='donor_universe_export.csv'; a.click();
  URL.revokeObjectURL(url);
}
$('btnExport').addEventListener('click', exportCSV);

/*** ---------- Initial UI ---------- ***/
setStatus('ready — WebGL 3D (influence, KPIs, CSV)');
</script>
</body>
</html>
