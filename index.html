<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smart Coin® — 3D Donor Dedication Map</title>
<style>
  :root { --bg:#0b1020; --text:#eaf0ff; --muted:#a7b0cc; --panel:#121a36; }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--text);
              font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
  header { padding:10px 14px; background:linear-gradient(90deg,#0f172a,#111831); border-bottom:1px solid #1f2a4d; }
  h1 { margin:0; font-size:16px; letter-spacing:.2px; }
  .wrap { display:grid; grid-template-columns: 320px 1fr; gap:12px; height:calc(100% - 52px); padding:12px; box-sizing:border-box; }
  .panel { background:var(--panel); border:1px solid #1f2a4d; border-radius:12px; padding:12px; overflow:auto; }
  .panel h2 { margin:2px 0 8px; font-size:14px; color:var(--muted); }
  .legend { font-size:12px; line-height:1.6; }
  .chip { display:inline-block; width:12px; height:12px; border-radius:50%; margin-right:6px; vertical-align:middle; border:1px solid #2f3b66;}
  #scene { width:100%; height:100%; border:1px solid #1f2a4d; border-radius:12px; position:relative; overflow:hidden; }
  .btn { display:inline-block; padding:6px 10px; border-radius:8px; background:#2b3f89; color:#fff; font-weight:600; text-decoration:none; border:1px solid #3e57c0; cursor:pointer; }
  .note { font-size:11px; color:#9aa3c9; margin-top:8px;}
  .stack { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  #status { font-size:12px; color:#9aa3c9; margin-top:10px; }
</style>
</head>
<body>
<header><h1>Smart Coin® — 3D Donor Dedication Map</h1></header>

<div class="wrap">
  <div class="panel">
    <h2>How to read this</h2>
    <div class="legend">
      <div><span class="chip" style="background:#1e3a8a"></span><b>Dark blue</b>: initial top donors (e.g., 250)</div>
      <div><span class="chip" style="background:#93c5fd"></span><b>Light blue</b>: each donor’s required “+1” supporter</div>
      <div><span class="chip" style="background:#22c55e"></span><b>Green</b>: extras when a donor finds &gt;1</div>
      <div><span class="chip" style="background:#ef4444"></span><b>Red</b>: downstream seeds from those extras</div>
    </div>
    <div class="note">
      • Drag to rotate · Scroll/Pinch to zoom · Right-drag to pan<br/>
      • Click any dot to highlight that donor’s <b>entire downline</b> (all descendants).
    </div>
    <div class="stack">
      <a id="modeCube" class="btn">Show Test Cube</a>
      <a id="modeMap"  class="btn">Show Donor Map</a>
      <a id="regen"    class="btn">Regenerate</a>
    </div>
    <div id="status">Status: ready</div>
  </div>
  <div class="panel"><div id="scene"></div></div>
</div>

<!-- Three.js only -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
(function(){
  // ===== Config =====
  const INITIAL_DONORS = 250;      // dark blue
  const EXTRA_PROB = 0.28;         // chance a donor makes extras
  const EXTRAS_MIN = 1, EXTRAS_MAX = 2;
  const RED_CHILDREN_PER_GREEN = 1;

  const COLOR_DARK = 0x1e3a8a, COLOR_LIGHT = 0x93c5fd, COLOR_GREEN = 0x22c55e, COLOR_RED = 0xef4444;
  const COLOR_EDGE_DIM = 0x5b6b95, COLOR_EDGE_HI = 0x6ee7ff;

  const sceneEl = document.getElementById('scene');
  const statusEl = document.getElementById('status');

  // ===== Three setup =====
  const renderer = new THREE.WebGLRenderer({antialias:true});
  sceneEl.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1020);

  const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 5000);
  camera.position.set(0, 240, 600);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.08;
  controls.rotateSpeed = 0.6; controls.zoomSpeed = 0.9; controls.panSpeed = 0.6;

  scene.add(new THREE.AmbientLight(0xffffff, 0.85));
  const dir = new THREE.DirectionalLight(0xffffff, 0.55); dir.position.set(300, 500, 400); scene.add(dir);

  // Robust sizing (works within Squarespace iframe)
  function setSizeToContainer() {
    const w = sceneEl.clientWidth || sceneEl.parentElement.clientWidth || window.innerWidth;
    const h = sceneEl.clientHeight || sceneEl.parentElement.clientHeight || Math.round(window.innerHeight * 0.7);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  }
  setTimeout(setSizeToContainer, 50);
  setTimeout(setSizeToContainer, 250);
  window.addEventListener('resize', setSizeToContainer);
  if ('ResizeObserver' in window) {
    const ro = new ResizeObserver(setSizeToContainer);
    ro.observe(sceneEl);
    ro.observe(document.body);
  }

  // ===== Utility =====
  function rng(seed=Date.now()){
    let t = seed>>>0;
    return ()=>{ t += 0x6D2B79F5; let r = Math.imul(t ^ t>>>15, 1 | t); r ^= r + Math.imul(r ^ r>>>7, 61 | r); return ((r ^ r>>>14)>>>0) / 4294967296; };
  }
  const rnd = rng();

  function fibSphere(n, radius=260){
    const pts=[]; const phi = Math.PI * (3 - Math.sqrt(5));
    for(let i=0;i<n;i++){
      const y = 1 - (i / Math.max(1,(n - 1))) * 2;
      const r = Math.sqrt(Math.max(0, 1 - y*y));
      const theta = phi * i;
      const x = Math.cos(theta) * r;
      const z = Math.sin(theta) * r;
      pts.push(new THREE.Vector3(x*radius, y*radius, z*radius));
    }
    return pts;
  }

  // ===== Scene objects (shared) =====
  let animationId = 0;
  let currentMode = 'map'; // 'cube' | 'map'
  let objectsToDispose = [];

  function clearSceneKeepLights(){
    // remove meshes/lines added previously
    for(const obj of objectsToDispose){
      scene.remove(obj);
      if(obj.geometry) obj.geometry.dispose();
      if(obj.material) obj.material.dispose();
    }
    objectsToDispose = [];
  }

  // ===== Test Cube Mode =====
  function showCube(){
    try{
      statusEl.textContent = 'Status: rendering test cube…';
      clearSceneKeepLights();

      const geo = new THREE.BoxGeometry(80,80,80);
      const mat = new THREE.MeshStandardMaterial({ color: 0x00ff66 });
      const cube = new THREE.Mesh(geo, mat);
      scene.add(cube); objectsToDispose.push(cube);

      cancelAnimationFrame(animationId);
      function loop(){
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.015;
        controls.update();
        renderer.render(scene, camera);
        animationId = requestAnimationFrame(loop);
      }
      setSizeToContainer();
      loop();
      currentMode = 'cube';
      statusEl.textContent = 'Status: cube mode — OK. Switch to “Show Donor Map” when ready.';
    }catch(err){
      statusEl.textContent = 'Error in cube mode: ' + err.message;
      console.error(err);
    }
  }

  // ===== Donor Map Mode =====
  function showMap(){
    try{
      statusEl.textContent = 'Status: building donor map…';

      // build graph
      const nodes=[], links=[];
      let id = 0;
      function addNode(type, parentId=null){
        const node = { id:id++, type, parent:parentId, children:[] };
        nodes.push(node);
        if(parentId!=null){
          links.push({source: parentId, target: node.id});
          const p = nodes.find(n=>n.id===parentId); if(p) p.children.push(node.id);
        }
        return node;
      }
      for(let i=0;i<INITIAL_DONORS;i++) addNode('dark', null);

      for(let i=0;i<INITIAL_DONORS;i++){
        const darkId = i;
        addNode('light', darkId);
        if(rnd() < EXTRA_PROB){
          const extras = Math.floor(rnd()*(EXTRAS_MAX-EXTRAS_MIN+1)) + EXTRAS_MIN;
          for(let k=0;k<extras;k++){
            const g = addNode('green', darkId);
            for(let r=0;r<RED_CHILDREN_PER_GREEN;r++) addNode('red', g.id);
          }
        }
      }
      const lightIds = nodes.filter(n=>n.type==='light').map(n=>n.id);
      lightIds.forEach(lid=>{
        addNode('light', lid);
        if(rnd() < EXTRA_PROB*0.7){
          const g = addNode('green', lid);
          addNode('red', g.id);
        }
      });

      // place nodes
      const dark = nodes.filter(n=>n.type==='dark');
      const pts = fibSphere(dark.length, 260);
      dark.forEach((n,i)=>{ n.x=pts[i].x; n.y=pts[i].y; n.z=pts[i].z; });
      nodes.forEach(n=>{
        if(n.type!=='dark'){
          const p = nodes.find(x=>x.id===n.parent) || {x:0,y:0,z:0};
          const j = ()=> (rnd()*2-1)*30;
          n.x = p.x + j(); n.y = p.y + j(); n.z = p.z + j();
        }
      });

      // draw nodes
      clearSceneKeepLights();
      const spheres=[], allObjects=[];
      function colorFor(type){
        if(type==='dark') return 0x1e3a8a;
        if(type==='light') return 0x93c5fd;
        if(type==='green') return 0x22c55e;
        return 0xef4444;
      }
      nodes.forEach(n=>{
        const size = n.type==='dark'? 5.2 : n.type==='light'? 4 : n.type==='green'? 4.4 : 3.8;
        const geo = new THREE.SphereGeometry(size, 18, 18);
        const mat = new THREE.MeshStandardMaterial({ color: colorFor(n.type), metalness:0.15, roughness:0.45 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(n.x, n.y, n.z);
        mesh.userData.id = n.id;
        scene.add(mesh); spheres.push(mesh); allObjects.push(mesh);
      });

      // draw edges
      const pos = new Float32Array(links.length*6);
      let i=0;
      links.forEach(l=>{
        const s = nodes.find(n=>n.id===l.source);
        const t = nodes.find(n=>n.id===l.target);
        pos[i++]=s.x; pos[i++]=s.y; pos[i++]=s.z;
        pos[i++]=t.x; pos[i++]=t.y; pos[i++]=t.z;
      });
      const edgeGeo = new THREE.BufferGeometry();
      edgeGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      const edgeMat = new THREE.LineBasicMaterial({ color: COLOR_EDGE_DIM, transparent:true, opacity:0.35 });
      const edgeLines = new THREE.LineSegments(edgeGeo, edgeMat);
      scene.add(edgeLines); allObjects.push(edgeLines);

      // highlight downline on click
      let glowLines = null;
      const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();

      function clearHighlight(){
        if(glowLines){ scene.remove(glowLines); glowLines.geometry.dispose(); glowLines.material.dispose(); glowLines = null; }
        spheres.forEach(m=>{ m.material.transparent=false; m.material.opacity=1; });
        edgeLines.material.opacity = 0.35;
      }

      function highlightDownline(startId){
        clearHighlight();
        const keep = new Set([startId]);
        const q = [startId];
        while(q.length){
          const cur = q.shift();
          links.filter(l=>l.source===cur).forEach(l=>{
            if(!keep.has(l.target)){ keep.add(l.target); q.push(l.target); }
          });
        }
        spheres.forEach(m=>{
          const on = keep.has(m.userData.id);
          m.material.transparent = true;
          m.material.opacity = on ? 1 : 0.12;
        });
        edgeLines.material.opacity = 0.08;

        const kept = links.filter(l=> keep.has(l.source) && keep.has(l.target));
        const glowPos = new Float32Array(kept.length*6);
        let j=0;
        kept.forEach(l=>{
          const s = nodes.find(n=>n.id===l.source);
          const t = nodes.find(n=>n.id===l.target);
          glowPos[j++]=s.x; glowPos[j++]=s.y; glowPos[j++]=s.z;
          glowPos[j++]=t.x; glowPos[j++]=t.y; glowPos[j++]=t.z;
        });
        const glowGeo = new THREE.BufferGeometry(); glowGeo.setAttribute('position', new THREE.BufferAttribute(glowPos,3));
        const glowMat = new THREE.LineBasicMaterial({ color: COLOR_EDGE_HI, transparent:true, opacity:0.95 });
        glowLines = new THREE.LineSegments(glowGeo, glowMat);
        scene.add(glowLines); allObjects.push(glowLines);
      }

      function onPointer(ev){
        const rect = renderer.domElement.getBoundingClientRect();
        const px = ( (ev.clientX||ev.touches?.[0].clientX) - rect.left ) / rect.width;
        const py = ( (ev.clientY||ev.touches?.[0].clientY) - rect.top ) / rect.height;
        mouse.x = px*2-1; mouse.y = -(py*2-1);
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(spheres, true);
        if(hits.length){ highlightDownline(hits[0].object.userData.id); }
        else { clearHighlight(); }
      }
      renderer.domElement.addEventListener('click', onPointer);
      renderer.domElement.addEventListener('touchend', onPointer);

      // animate
      cancelAnimationFrame(animationId);
      function loop(){
        controls.update();
        renderer.render(scene, camera);
        animationId = requestAnimationFrame(loop);
      }
      setSizeToContainer();
      loop();

      // track disposables
      objectsToDispose = allObjects;
      currentMode = 'map';
      statusEl.textContent = 'Status: donor map mode — OK. Click a node to highlight full downline.';
    }catch(err){
      statusEl.textContent = 'Error in donor map mode: ' + err.message;
      console.error(err);
    }
  }

  // ===== Buttons =====
  document.getElementById('modeCube').addEventListener('click', e=>{ e.preventDefault(); showCube(); });
  document.getElementById('modeMap').addEventListener('click',  e=>{ e.preventDefault(); showMap(); });
  document.getElementById('regen').addEventListener('click',    e=>{
    e.preventDefault();
    if(currentMode==='map') showMap(); else showCube();
  });

  // ===== Start in donor map (you can click "Show Test Cube" if needed) =====
  showMap();

  // Safety: ensure size once more after layout settles
  setTimeout(setSizeToContainer, 500);
})();
</script>
</body>
</html>
