<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Smart Coin™ — Donor Universe (Canvas 2D, Bloom + Live Totals)</title>
<style>
  :root{ --bg:#000; --panel:#111826; --text:#eaf0ff; --muted:#9aa3c9; --border:#1f2a4d; --accent:#6ee7ff; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #app{position:relative;width:100%;height:100vh;min-height:560px;background:#000;overflow:hidden}
  #status{position:fixed;left:10px;bottom:10px;z-index:10;background:var(--panel);color:var(--muted);
    border:1px solid var(--border);border-radius:8px;padding:6px 10px;font-size:12px;max-width:80vw;white-space:pre-wrap}
  #legend{position:fixed;left:10px;top:10px;z-index:10;background:var(--panel);
    border:1px solid var(--border);border-radius:8px;padding:6px 8px;font-size:12px;color:#cfe1ff;opacity:.92}
  .chip{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;border:1px solid #2f3b66}
  #counters{position:fixed;left:50%;top:10px;transform:translateX(-50%);z-index:10;display:flex;gap:10px}
  .pill{background:var(--panel);border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:13px;opacity:.96}
  .pill b{font-weight:700}
  #buttons{position:fixed;right:10px;top:10px;z-index:10;display:flex;gap:8px}
  .btn{background:var(--panel);color:#eaf0ff;border:1px solid var(--border);border-radius:999px;padding:8px 10px;font-size:12px;cursor:pointer}
  #help{position:fixed;right:10px;top:44px;z-index:10;background:var(--panel);border:1px solid var(--border);
    border-radius:10px;padding:10px 12px;font-size:12px;display:none;max-width:360px}
  #help.open{display:block}
  #timeline{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);z-index:10;width:min(520px,70vw);height:8px;
    background:var(--panel);border:1px solid var(--border);border-radius:999px;overflow:hidden;box-shadow:0 2px 10px rgba(0,0,0,.25)}
  #tlFill{height:100%;width:0%;background:var(--accent);opacity:.95}
  #tip{position:fixed;pointer-events:none;z-index:11;background:#0b1020;border:1px solid #223054;border-radius:6px;
    padding:6px 8px;font-size:12px;display:none;color:#dce6ff}
  @media (max-width:768px){ #counters{top:auto;bottom:38px} }
</style>
</head>
<body>
<div id="app"></div>
<canvas id="cv"></canvas>

<div id="legend">
  <div><span class="chip" style="background:#1e3a8a"></span>Dark blue: roots</div>
  <div><span class="chip" style="background:#93c5fd"></span>Light blue: primary +1 (max 1 per parent)</div>
  <div><span class="chip" style="background:#22c55e"></span>Green: extras (other donations)</div>
  <div><span class="chip" style="background:#ef4444"></span>Red: everything below any green</div>
</div>

<div id="counters">
  <div class="pill">Coins: <b id="coinsVal">0</b></div>
  <div class="pill">Raised: <b id="raisedVal">$0</b></div>
</div>

<div id="buttons">
  <button id="btnBloom" class="btn">⏸ Bloom</button>
  <button id="btnHelp" class="btn">?</button>
</div>
<div id="help">
  <b>Controls</b><br>
  • Drag = rotate space • Ctrl/Right-drag = pan • Wheel = zoom<br>
  • Click a node to highlight its constellation + influence so far<br>
  • B = play/pause Bloom · Shift+B = restart · H = toggle this help<br><br>
  <i>Counters:</i> Coins = nodes born so far. Raised = coins×$50 + gifts (skewed $50→$5,000).
</div>

<div id="timeline" aria-hidden="true"><div id="tlFill"></div></div>
<div id="tip"></div>
<div id="status">Status: ready — Canvas mode</div>

<script>
/* ---------- small utilities ---------- */
const $=(id)=>document.getElementById(id);
const statusEl=$('status'), cv=$('cv'), app=$('app'), ctx=cv.getContext('2d');
const fmtMoney=(n)=>n.toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
const easeOutCubic=t=>1-Math.pow(1-Math.min(1,Math.max(0,t)),3);
function setStatus(m){statusEl.textContent='Status: '+m;}
function xmur3(str){for(var i=0,h=1779033703^str.length;i<str.length;i++)h=Math.imul(h^str.charCodeAt(i),3432918353),h=h<<13|h>>>19;return function(){h=Math.imul(h^(h>>>16),2246822507);h=Math.imul(h^(h>>>13),3266489909);return(h^(h>>>16))>>>0}}
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
function makeRNG(seedStr){if(!seedStr) return Math.random; const seed=xmur3(String(seedStr))(); return mulberry32(seed)}
function roundTo(v,step){return Math.round(v/step)*step}
function poisson(lambda,rand){if(lambda<=0) return 0; const L=Math.exp(-lambda); let k=0,p=1; do{k++;p*=rand()}while(p>L); return k-1}

/* Gifts: right-skewed — many $50, rare $5k */
function sampleGift(rand){
  const u=rand();
  if(u<0.60) return 50;
  if(u<0.78) return roundTo(50 + rand()*100, 5);
  if(u<0.90) return roundTo(150 + rand()*350, 10);
  if(u<0.98) return roundTo(500 + rand()*1500, 25);
  return roundTo(2000 + rand()*3000, 50);
}

/* ---------- parameters ---------- */
const P={
  roots:250,
  lightDepth:10, lightProb:.85, lightFan:1.5, lightDecay:.90,
  extraDepth:9,  extraProb:.85, extraFan:1.8, extraDecay:.88,
  radius:800, jitter:36, cap:20000, seed:'universe-250-2d'
};

/* ---------- build donor graph (one-light per parent) + births + gifts ----------*/
function buildGraph(P){
  const rand=makeRNG(P.seed), randJ=makeRNG(P.seed+'j'), randG=makeRNG(P.seed+'g');
  const ROOT_STAGGER=140, STEP_LIGHT=560, STEP_GREEN=420, STEP_RED=300;
  const nodes=[], links=[], roots=[];
  let id=0;
  function addNode(type,parent=null,branch='light',bdepth=0,birth=0){
    if(nodes.length>=P.cap) return null;
    const gift = sampleGift(randG);
    const n={id:id++,type,parent,children:[],branch,bdepth,birth,gift,x:0,y:0,z:0};
    nodes.push(n);
    if(parent!=null){links.push({source:parent,target:n.id}); nodes[parent].children.push(n.id);}
    return n;
  }
  // roots with gentle birth jitter
  for(let i=0;i<P.roots;i++){ const b=i*ROOT_STAGGER + rand()*80; const r=addNode('dark',null,'light',0,b); if(r) roots.push(r.id); }

  // BFS growth (max one light child; extras become green; red below green)
  const q=roots.map(id=>({id}));
  while(q.length && nodes.length<P.cap){
    const pid=q.shift().id; const p=nodes[pid];
    if(p.branch==='light' && p.bdepth<P.lightDepth){
      const scale=Math.pow(P.lightDecay, Math.max(0,p.bdepth));
      if(rand() < P.lightProb*scale){
        let k=poisson(Math.max(0, P.lightFan*scale), rand);
        if(k>0){
          const lb=p.birth + STEP_LIGHT*(0.8+0.4*rand());
          const c=addNode('light', pid, 'light', p.bdepth+1, lb); if(c) q.push({id:c.id});
          for(let i=1;i<k;i++){
            const gb=p.birth + STEP_GREEN*(0.65+0.5*rand());
            const g=addNode('green', pid, 'extra', 1, gb); if(g) q.push({id:g.id});
          }
        }
      }
    } else if(p.branch==='extra' && p.bdepth<P.extraDepth){
      const scale=Math.pow(P.extraDecay, Math.max(0,p.bdepth-1));
      if(rand() < P.extraProb*scale){
        let k=poisson(Math.max(0, P.extraFan*scale), rand);
        for(let i=0;i<k;i++){
          const rb=p.birth + STEP_RED*(0.6+0.5*rand());
          const r=addNode('red', pid, 'extra', p.bdepth+1, rb); if(r) q.push({id:r.id});
        }
      }
    }
  }

  // layout: fibonacci sphere for roots, jitter for children
  function fibSphere(n,r=P.radius){const pts=[],phi=Math.PI*(3-Math.sqrt(5));
    for(let i=0;i<n;i++){const y=1-(i/Math.max(1,n-1))*2; const rad=Math.sqrt(Math.max(0,1-y*y)); const th=phi*i;
      pts.push({x:Math.cos(th)*rad*r,y:y*r,z:Math.sin(th)*rad*r});} return pts;}
  const rootsObjs=nodes.filter(n=>n.type==='dark'), pts=fibSphere(rootsObjs.length,P.radius);
  rootsObjs.forEach((n,i)=>{n.x=pts[i].x; n.y=pts[i].y; n.z=pts[i].z;});
  nodes.forEach(n=>{
    if(n.type!=='dark'){
      const p=nodes[n.parent]||{x:0,y:0,z:0};
      const spread=P.jitter*(1+0.04*Math.max(0,n.bdepth-1));
      const j=()=> (randJ()*2-1)*spread;
      n.x=p.x+j(); n.y=p.y+j(); n.z=p.z+j();
    }
  });

  // births/gifts prefix for fast counters
  const byBirth=nodes.slice().sort((a,b)=>a.birth-b.birth);
  const birthsSorted=byBirth.map(n=>n.birth);
  let acc=0; const giftPrefix=byBirth.map(n=>{acc+=n.gift; return acc;});
  const maxBirth=nodes.reduce((m,n)=>Math.max(m,n.birth), 0);
  return {nodes,links,roots,birthsSorted,giftPrefix,maxBirth};
}

/* ---------- canvas camera / projection ---------- */
let yaw=0, pitch=0, dist=1100, tx=0, ty=0;
let dragging=false, rotating=false, lastX=0,lastY=0;
cv.addEventListener('mousedown',e=>{dragging=true; rotating=(e.button===2||e.ctrlKey); lastX=e.clientX; lastY=e.clientY;});
window.addEventListener('mouseup',()=>dragging=false);
window.addEventListener('contextmenu',e=>{if(e.target===cv) e.preventDefault();});
window.addEventListener('mousemove',e=>{
  if(!dragging) return;
  const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
  if(rotating){ yaw+=dx*0.005; pitch=Math.max(-1.2, Math.min(1.2, pitch+dy*0.005)); }
  else { tx+=dx; ty+=dy; }
});
cv.addEventListener('wheel',e=>{ e.preventDefault(); dist=Math.max(200, Math.min(3000, dist + e.deltaY)); }, {passive:false});

function project(v){
  const cosy=Math.cos(yaw), siny=Math.sin(yaw);
  const cosx=Math.cos(pitch), sinx=Math.sin(pitch);
  let x=v.x*cosy - v.z*siny;
  let z=v.x*siny + v.z*cosy;
  let y=v.y*cosx - z*sinx;
  z = v.y*sinx + z*cosx;
  const f=dist, s=f/(f+z+1e-3);
  return {x:x*s + cv.width/dpr/2 + tx, y:y*s + cv.height/dpr/2 + ty, s};
}

/* ---------- render + interaction ---------- */
const COLOR={dark:'#1e3a8a', light:'#93c5fd', green:'#22c55e', red:'#ef4444', edge:'rgba(91,107,149,0.14)', cyan:'rgba(110,231,255,0.9)'};
const radiusOf=(t)=> t==='dark'?5.2 : t==='light'?4 : t==='green'?4.4 : 3.8;

let dpr=1;
function resize(){
  dpr=window.devicePixelRatio||1;
  const w=app.clientWidth||window.innerWidth, h=app.clientHeight||window.innerHeight;
  cv.width = w*dpr; cv.height = h*dpr; cv.style.width=w+'px'; cv.style.height=h+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize); resize();

/* ---------- build model ---------- */
const model = buildGraph(P);

/* ---------- bloom + counters ---------- */
const BLOOM={playing:true,t:0,duration:model.maxBirth+2000,start:performance.now()};
const tlFill=$('tlFill'), coinsVal=$('coinsVal'), raisedVal=$('raisedVal');
function upperBound(arr,val){let lo=0,hi=arr.length; while(lo<hi){const mid=(lo+hi)>>1; if(arr[mid]<=val) lo=mid+1; else hi=mid;} return lo;}
function updateCounters(t){
  const idx=upperBound(model.birthsSorted,t);
  const coins=idx;
  const gifts = idx?model.giftPrefix[idx-1]:0;
  const raised = coins*50 + gifts;
  coinsVal.textContent = coins.toLocaleString('en-US');
  raisedVal.textContent = fmtMoney(Math.round(raised));
}

/* ---------- picking / highlight ---------- */
let screenPos=new Array(model.nodes.length);
let highlightSet=null;
cv.addEventListener('click',e=>{
  const rect=cv.getBoundingClientRect(); const mx=(e.clientX-rect.left), my=(e.clientY-rect.top);
  // pick nearest point within 12px
  let best=-1, bestD=12;
  for(let i=0;i<model.nodes.length;i++){
    const p=screenPos[i]; if(!p) continue;
    const dx=mx-p.x, dy=my-p.y; const d=Math.hypot(dx,dy);
    if(d<bestD){ bestD=d; best=i; }
  }
  if(best>=0){
    const keep=new Set([best]), q=[best];
    while(q.length){const cur=q.shift(); model.nodes[cur].children.forEach(ch=>{if(!keep.has(ch)){keep.add(ch); q.push(ch)}})}
    highlightSet=keep;

    // influence so far
    const t=BLOOM.t;
    const vis=[...keep].filter(i=> model.nodes[i].birth<=t);
    const coins=vis.length;
    const gifts=vis.reduce((s,i)=>s+model.nodes[i].gift,0);
    const raised=coins*50 + gifts;
    const selfGift=model.nodes[best].gift + 50;
    const network=raised - selfGift;
    setStatus(`selected #${best} — direct ${fmtMoney(selfGift)} · constellation ${coins-1} others raising ${fmtMoney(network)} (total ${fmtMoney(raised)})`);
  } else {
    highlightSet=null;
  }
});

/* ---------- buttons / keys ---------- */
$('btnHelp').addEventListener('click', ()=> $('help').classList.toggle('open'));
$('btnBloom').addEventListener('click', ()=>{
  BLOOM.playing=!BLOOM.playing; $('btnBloom').textContent=BLOOM.playing?'⏸ Bloom':'⏵ Bloom';
  if(BLOOM.playing) BLOOM.start=performance.now()-BLOOM.t;
});
window.addEventListener('keydown',e=>{
  if(e.key==='h'||e.key==='H') $('help').classList.toggle('open');
  if(e.key==='b'||e.key==='B'){
    if(e.shiftKey){ BLOOM.t=0; BLOOM.playing=false; $('btnBloom').textContent='⏵ Bloom'; tlFill.style.width='0%'; updateCounters(BLOOM.t); }
    else { BLOOM.playing=!BLOOM.playing; $('btnBloom').textContent=BLOOM.playing?'⏸ Bloom':'⏵ Bloom'; if(BLOOM.playing) BLOOM.start=performance.now()-BLOOM.t; }
  }
});

/* ---------- main draw loop ---------- */
function draw(){
  const w=cv.width/dpr, h=cv.height/dpr;
  ctx.clearRect(0,0,w,h);

  // tick bloom
  if(BLOOM.playing){
    BLOOM.t=Math.min(BLOOM.duration, performance.now()-BLOOM.start);
    if(BLOOM.t>=BLOOM.duration){ BLOOM.playing=false; $('btnBloom').textContent='⏵ Bloom'; }
  }

  // project points
  for(let i=0;i<model.nodes.length;i++) screenPos[i]=project(model.nodes[i]);

  // faint edges
  ctx.lineWidth=1; ctx.strokeStyle='rgba(91,107,149,0.14)'; ctx.beginPath();
  for(const l of model.links){ const a=screenPos[l.source], b=screenPos[l.target]; if(!a||!b) continue; ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); }
  ctx.stroke();

  // cyan edges for “born” links
  ctx.lineWidth=1; ctx.strokeStyle=COLOR.cyan; ctx.beginPath();
  for(const l of model.links){ if(model.nodes[l.target].birth > BLOOM.t) continue; const a=screenPos[l.source], b=screenPos[l.target]; if(!a||!b) continue; ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); }
  ctx.stroke();

  // nodes
  for(const n of model.nodes){
    const p=screenPos[n.id]; if(!p) continue;
    const a=easeOutCubic((BLOOM.t - n.birth)/420); if(a<=0) continue;
    const base = radiusOf(n.type);
    const r = Math.max(1, base*(0.6 + 0.6*p.s)*a);
    const col = (n.type==='dark')?COLOR.dark : (n.type==='light')?COLOR.light : (n.type==='green')?COLOR.green : COLOR.red;
    ctx.globalAlpha = highlightSet ? (highlightSet.has(n.id)?1:0.10) : a;
    ctx.beginPath(); ctx.fillStyle=col; ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // counters + timeline
  updateCounters(BLOOM.t);
  $('tlFill').style.width = `${Math.min(100,(BLOOM.t/BLOOM.duration)*100)}%`;

  requestAnimationFrame(draw);
}
draw();

// ready
setStatus('ready — Canvas mode (no external libs)');
</script>
</body>
</html>
