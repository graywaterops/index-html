<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Smart Coin® — 3D Donor Map (sanity + map)</title>
<style>
  :root{--bg:#0b1020;--panel:#121a36;--text:#eaf0ff;--muted:#9aa3c9}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #app{position:relative;width:100%;height:100%}
  #status{
    position:fixed;left:10px;bottom:10px;z-index:10;
    background:var(--panel);color:var(--muted);border:1px solid #1f2a4d;border-radius:8px;
    padding:6px 10px;font-size:12px;max-width:70vw;white-space:pre-wrap
  }
  #legend{
    position:fixed;left:10px;top:10px;z-index:10;background:var(--panel);
    border:1px solid #1f2a4d;border-radius:8px;padding:8px 10px;font-size:12px;color:#cfe1ff
  }
  .chip{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:middle;border:1px solid #2f3b66}
</style>
</head>
<body>
<div id="app"></div>

<div id="legend">
  <div><span class="chip" style="background:#1e3a8a"></span>Dark blue: initial donors</div>
  <div><span class="chip" style="background:#93c5fd"></span>Light blue: each donor’s +1</div>
  <div><span class="chip" style="background:#22c55e"></span>Green: extras (&gt;1)</div>
  <div><span class="chip" style="background:#ef4444"></span>Red: downstream from extras</div>
</div>
<div id="status">Status: loading…</div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
(function(){
  const statusEl = document.getElementById('status');
  function setStatus(msg){
    statusEl.textContent = 'Status: ' + msg;
  }
  function showError(err){
    statusEl.textContent = 'Error: ' + (err && err.message ? err.message : err);
    console.error(err);
  }

  // --- Three setup with hard sizing (prevents 0x0 canvas) ---
  const root = document.getElementById('app');
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  root.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1020);
  const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 5000);
  camera.position.set(0, 0, 600);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  scene.add(new THREE.AmbientLight(0xffffff, 0.9));
  const dir = new THREE.DirectionalLight(0xffffff, 0.5);
  dir.position.set(300,500,400); scene.add(dir);

  function resize(){
    // If inside Squarespace iframe, clientHeight can be 0 at first → fallback
    const w = root.clientWidth  || root.parentElement.clientWidth  || window.innerWidth;
    const h = root.clientHeight || root.parentElement.clientHeight || Math.round(window.innerHeight*0.7);
    camera.aspect = w/h; camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  }
  window.addEventListener('resize', resize);
  setTimeout(resize, 30);
  setTimeout(resize, 250);

  if ('ResizeObserver' in window){
    const ro = new ResizeObserver(resize);
    ro.observe(root); ro.observe(document.body);
  }

  // --- Pass 1: draw a test cube (so we know rendering works) ---
  try{
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(120,120,120),
      new THREE.MeshStandardMaterial({ color: 0x00ff66 })
    );
    scene.add(cube);

    let animId = 0;
    function loop(){
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.015;
      controls.update();
      renderer.render(scene, camera);
      animId = requestAnimationFrame(loop);
    }
    setStatus('rendering test cube…');
    loop();

    // After 1 second, switch to donor map
    setTimeout(()=>{
      cancelAnimationFrame(animId);
      scene.remove(cube); cube.geometry.dispose(); cube.material.dispose();
      drawDonorMap();
    }, 1000);
  }catch(err){ showError(err); }

  // --- Pass 2: donor map (small sample so we see something immediately) ---
  function drawDonorMap(){
    setStatus('building donor map…');

    const COLOR_DARK = 0x1e3a8a, COLOR_LIGHT = 0x93c5fd, COLOR_GREEN = 0x22c55e, COLOR_RED = 0xef4444;
    const COLOR_EDGE = 0x5b6b95, COLOR_HI = 0x6ee7ff;

    const INITIAL_DONORS = 80;      // start small so it’s definitely visible
    const EXTRA_PROB = 0.3;
    const rnd = () => Math.random();

    const nodes=[], links=[];
    let id=0;
    function addNode(type, parent=null){
      const n={id:id++, type, parent, children:[]}; nodes.push(n);
      if(parent!=null){ links.push({source:parent, target:n.id}); nodes[parent].children.push(n.id); }
      return n;
    }
    // dark
    for(let i=0;i<INITIAL_DONORS;i++) addNode('dark', null);
    // each dark -> one light, some -> green+red
    for(let i=0;i<INITIAL_DONORS;i++){
      const d=i;
      addNode('light', d);
      if(rnd()<EXTRA_PROB){
        const g = addNode('green', d);
        addNode('red', g.id);
      }
    }
    // each light -> one more light
    nodes.filter(n=>n.type==='light').forEach(l => addNode('light', l.id));

    // position: fibonacci sphere for dark; others around their parent
    function fibSphere(n, radius=260){
      const pts=[]; const phi = Math.PI*(3-Math.sqrt(5));
      for(let i=0;i<n;i++){
        const y=1-(i/Math.max(1,(n-1)))*2; const r=Math.sqrt(Math.max(0,1-y*y));
        const th=phi*i; const x=Math.cos(th)*r; const z=Math.sin(th)*r;
        pts.push(new THREE.Vector3(x*radius,y*radius,z*radius));
      } return pts;
    }
    const dark = nodes.filter(n=>n.type==='dark');
    const pts = fibSphere(dark.length, 260);
    dark.forEach((n,i)=>{ n.x=pts[i].x; n.y=pts[i].y; n.z=pts[i].z; });
    nodes.forEach(n=>{
      if(n.type!=='dark'){
        const p = nodes.find(x=>x.id===n.parent) || {x:0,y:0,z:0};
        const j = ()=> (Math.random()*2-1)*28;
        n.x = p.x + j(); n.y = p.y + j(); n.z = p.z + j();
      }
    });

    // draw nodes
    const spheres=[];
    function colorFor(t){return t==='dark'?COLOR_DARK:t==='light'?COLOR_LIGHT:t==='green'?COLOR_GREEN:COLOR_RED}
    nodes.forEach(n=>{
      const size = n.type==='dark'?5.2:n.type==='light'?4:n.type==='green'?4.4:3.8;
      const mesh = new THREE.Mesh(new THREE.SphereGeometry(size,18,18), new THREE.MeshStandardMaterial({color:colorFor(n.type), metalness:0.15, roughness:0.45}));
      mesh.position.set(n.x,n.y,n.z); mesh.userData.id=n.id;
      scene.add(mesh); spheres.push(mesh);
    });

    // draw edges
    const pos = new Float32Array(links.length*6);
    let k=0;
    links.forEach(l=>{
      const s = nodes.find(n=>n.id===l.source), t = nodes.find(n=>n.id===l.target);
      pos[k++]=s.x; pos[k++]=s.y; pos[k++]=s.z;
      pos[k++]=t.x; pos[k++]=t.y; pos[k++]=t.z;
    });
    const edgeGeo = new THREE.BufferGeometry(); edgeGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const edgeMat = new THREE.LineBasicMaterial({color:COLOR_EDGE, transparent:true, opacity:0.35});
    const edges = new THREE.LineSegments(edgeGeo, edgeMat); scene.add(edges);

    // click highlight (downline)
    let glow = null;
    const ray = new THREE.Raycaster(), mouse = new THREE.Vector2();
    function clearHi(){
      if(glow){ scene.remove(glow); glow.geometry.dispose(); glow.material.dispose(); glow=null; }
      spheres.forEach(m=>{ m.material.transparent=false; m.material.opacity=1; });
      edges.material.opacity=0.35;
    }
    function highlight(startId){
      clearHi();
      const keep=new Set([startId]), q=[startId];
      while(q.length){
        const cur=q.shift();
        links.filter(l=>l.source===cur).forEach(l=>{
          if(!keep.has(l.target)){ keep.add(l.target); q.push(l.target); }
        });
      }
      spheres.forEach(m=>{
        const on=keep.has(m.userData.id);
        m.material.transparent=true; m.material.opacity=on?1:0.12;
      });
      edges.material.opacity=0.08;

      const kept = links.filter(l=> keep.has(l.source) && keep.has(l.target));
      const gpos = new Float32Array(kept.length*6); let i=0;
      kept.forEach(l=>{
        const s = nodes.find(n=>n.id===l.source), t = nodes.find(n=>n.id===l.target);
        gpos[i++]=s.x; gpos[i++]=s.y; gpos[i++]=s.z;
        gpos[i++]=t.x; gpos[i++]=t.y; gpos[i++]=t.z;
      });
      const ggeo = new THREE.BufferGeometry(); ggeo.setAttribute('position', new THREE.BufferAttribute(gpos,3));
      glow = new THREE.LineSegments(ggeo, new THREE.LineBasicMaterial({color:COLOR_HI, transparent:true, opacity:0.95}));
      scene.add(glow);
    }
    function onPointer(ev){
      const rect = renderer.domElement.getBoundingClientRect();
      const px = ((ev.clientX||ev.touches?.[0]?.clientX)-rect.left)/rect.width;
      const py = ((ev.clientY||ev.touches?.[0]?.clientY)-rect.top)/rect.height;
      mouse.x = px*2-1; mouse.y = -(py*2-1);
      ray.setFromCamera(mouse, camera);
      const hits = ray.intersectObjects(spheres, true);
      if(hits.length){ highlight(hits[0].object.userData.id); }
      else{ clearHi(); }
    }
    renderer.domElement.addEventListener('click', onPointer);
    renderer.domElement.addEventListener('touchend', onPointer);

    // animate
    function loop(){
      controls.update(); renderer.render(scene,camera); requestAnimationFrame(loop);
    }
    resize(); setStatus('donor map ready — rotate/zoom, click to highlight downline');
    loop();
  }
})();
</script>
</body>
</html>
