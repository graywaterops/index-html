<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Smart Coin™ — Donor Universe (Pure WebGL 3D)</title>
<style>
  :root{ --bg:#000; --panel:#111826; --text:#eaf0ff; --muted:#9aa3c9; --border:#1f2a4d; --accent:#6ee7ff; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #app{position:relative;width:100%;height:100vh;min-height:560px;background:#000;overflow:hidden}
  canvas#gl{position:absolute; inset:0; width:100%; height:100%; display:block}

  #legend{position:fixed;left:10px;top:10px;z-index:10;background:var(--panel);
    border:1px solid var(--border);border-radius:8px;padding:6px 8px;font-size:12px;color:#cfe1ff;opacity:.92}
  .chip{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;border:1px solid #2f3b66}
  #status{position:fixed;left:10px;bottom:10px;z-index:10;background:var(--panel);color:var(--muted);
    border:1px solid var(--border);border-radius:8px;padding:6px 10px;font-size:12px;max-width:78vw;white-space:pre-wrap}
  #counters{position:fixed;left:50%;top:10px;transform:translateX(-50%);z-index:10;display:flex;gap:10px}
  .pill{background:var(--panel);border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:13px;opacity:.96}
  .pill b{font-weight:700}
  #buttons{position:fixed;right:10px;top:10px;z-index:10;display:flex;gap:8px}
  .btn{background:var(--panel);color:#eaf0ff;border:1px solid var(--border);border-radius:999px;padding:8px 10px;font-size:12px;cursor:pointer}
  #help{position:fixed;right:10px;top:44px;z-index:10;background:var(--panel);border:1px solid var(--border);
    border-radius:10px;padding:10px 12px;font-size:12px;display:none;max-width:360px}
  #help.open{display:block}
  #timeline{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);z-index:10;width:min(520px,70vw);height:8px;
    background:var(--panel);border:1px solid var(--border);border-radius:999px;overflow:hidden;box-shadow:0 2px 10px rgba(0,0,0,.25)}
  #tlFill{height:100%;width:0%;background:var(--accent);opacity:.95}
  #tip{position:fixed;pointer-events:none;z-index:11;background:#0b1020;border:1px solid #223054;border-radius:6px;
    padding:6px 8px;font-size:12px;display:none;color:#dce6ff}
  @media (max-width:768px){ #counters{top:auto;bottom:38px} }
</style>
</head>
<body>
<div id="app">
  <canvas id="gl"></canvas>
</div>

<div id="legend">
  <div><span class="chip" style="background:#1e3a8a"></span>Dark blue: roots</div>
  <div><span class="chip" style="background:#93c5fd"></span>Light blue: primary +1 (max 1 per parent)</div>
  <div><span class="chip" style="background:#22c55e"></span>Green: extras (other donations)</div>
  <div><span class="chip" style="background:#ef4444"></span>Red: everything below any green</div>
</div>

<div id="counters">
  <div class="pill">Coins: <b id="coinsVal">0</b></div>
  <div class="pill">Raised: <b id="raisedVal">$0</b></div>
</div>

<div id="buttons">
  <button id="btnBloom" class="btn">⏸ Bloom</button>
  <button id="btnHelp" class="btn">?</button>
</div>
<div id="help">
  <b>Controls</b><br>
  • Left-drag: rotate · Right/Ctrl-drag: pan · Wheel: zoom<br>
  • Click a node to highlight its constellation + influence so far<br>
  • B = play/pause · Shift+B = restart · H = toggle help<br><br>
  <i>Counters:</i> Coins = nodes born so far. Raised = coins×$50 + gifts (skewed $50→$5,000).
</div>

<div id="timeline"><div id="tlFill"></div></div>
<div id="tip"></div>
<div id="status">Status: loading…</div>

<script>
/*** ---------- Small utilities ---------- ***/
const $ = (id)=>document.getElementById(id);
const statusEl = $('status');
const tipEl = $('tip');
const tlFill = $('tlFill');
const coinsVal = $('coinsVal');
const raisedVal = $('raisedVal');
const fmtMoney = (n)=> n.toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
const setStatus=(m)=> statusEl.textContent='Status: ' + m;
const easeOutCubic=t=>1-Math.pow(1-Math.min(1,Math.max(0,t)),3);
function xmur3(str){for(var i=0,h=1779033703^str.length;i<str.length;i++)h=Math.imul(h^str.charCodeAt(i),3432918353),h=h<<13|h>>>19;return function(){h=Math.imul(h^(h>>>16),2246822507);h=Math.imul(h^(h>>>13),3266489909);return(h^(h>>>16))>>>0}}
function mulberry32(a){return function(){var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return((t^t>>>14)>>>0)/4294967296}}
function makeRNG(s){if(!s) return Math.random; const seed=xmur3(String(s))(); return mulberry32(seed)}
function roundTo(v,step){return Math.round(v/step)*step}
function poisson(lambda,rand){if(lambda<=0)return 0; const L=Math.exp(-lambda); let k=0,p=1; do{k++;p*=rand()}while(p>L); return k-1}
function sampleGift(rand){const u=rand(); if(u<0.60) return 50; if(u<0.78) return roundTo(50+rand()*100,5); if(u<0.90) return roundTo(150+rand()*350,10); if(u<0.98) return roundTo(500+rand()*1500,25); return roundTo(2000+rand()*3000,50);}

/*** ---------- Model parameters ---------- ***/
const P={ roots:250,
  lightDepth:10, lightProb:.85, lightFan:1.5, lightDecay:.90,
  extraDepth:9,  extraProb:.85, extraFan:1.8, extraDecay:.88,
  radius:800, jitter:36, cap:20000, seed:'universe-250-webgl'
};

/*** ---------- Build donor graph (one-light-per-parent) ---------- ***/
function buildGraph(P){
  const rand=makeRNG(P.seed), randJ=makeRNG(P.seed+'j'), randG=makeRNG(P.seed+'g');
  const ROOT_STAGGER=140, STEP_LIGHT=560, STEP_GREEN=420, STEP_RED=300;
  const nodes=[], links=[], roots=[];
  let id=0;
  function addNode(type,parent=null,branch='light',bdepth=0,birth=0){
    if(nodes.length>=P.cap) return null;
    const gift=sampleGift(randG);
    const n={id:id++,type,parent,children:[],branch,bdepth,birth,gift,x:0,y:0,z:0};
    nodes.push(n);
    if(parent!=null){links.push({source:parent,target:n.id}); nodes[parent].children.push(n.id);}
    return n;
  }
  for(let i=0;i<P.roots;i++){const b=i*ROOT_STAGGER+rand()*80; const r=addNode('dark',null,'light',0,b); if(r) roots.push(r.id);}
  const q=roots.map(id=>({id}));
  while(q.length && nodes.length<P.cap){
    const pid=q.shift().id; const p=nodes[pid];
    if(p.branch==='light' && p.bdepth<P.lightDepth){
      const scale=Math.pow(P.lightDecay, Math.max(0,p.bdepth));
      if(rand()<P.lightProb*scale){
        let k=poisson(Math.max(0,P.lightFan*scale), rand);
        if(k>0){
          const lb=p.birth+STEP_LIGHT*(0.8+0.4*rand());
          const c=addNode('light',pid,'light',p.bdepth+1,lb); if(c) q.push({id:c.id});
          for(let i=1;i<k;i++){
            const gb=p.birth+STEP_GREEN*(0.65+0.5*rand());
            const g=addNode('green',pid,'extra',1,gb); if(g) q.push({id:g.id});
          }
        }
      }
    } else if(p.branch==='extra' && p.bdepth<P.extraDepth){
      const scale=Math.pow(P.extraDecay, Math.max(0,p.bdepth-1));
      if(rand()<P.extraProb*scale){
        let k=poisson(Math.max(0,P.extraFan*scale), rand);
        for(let i=0;i<k;i++){
          const rb=p.birth+STEP_RED*(0.6+0.5*rand());
          const r=addNode('red',pid,'extra',p.bdepth+1,rb); if(r) q.push({id:r.id});
        }
      }
    }
  }
  // layout
  function fibSphere(n,r=P.radius){const pts=[],phi=Math.PI*(3-Math.sqrt(5));
    for(let i=0;i<n;i++){const y=1-(i/Math.max(1,n-1))*2; const rad=Math.sqrt(Math.max(0,1-y*y)); const th=phi*i;
      pts.push({x:Math.cos(th)*rad*r,y:y*r,z:Math.sin(th)*rad*r});}
    return pts;
  }
  const rootsObjs=nodes.filter(n=>n.type==='dark'), pts=fibSphere(rootsObjs.length,P.radius);
  rootsObjs.forEach((n,i)=>{n.x=pts[i].x; n.y=pts[i].y; n.z=pts[i].z;});
  nodes.forEach(n=>{
    if(n.type!=='dark'){
      const p=nodes[n.parent]||{x:0,y:0,z:0};
      const spread=P.jitter*(1+0.04*Math.max(0,n.bdepth-1));
      const j=()=> (randJ()*2-1)*spread;
      n.x=p.x+j(); n.y=p.y+j(); n.z=p.z+j();
    }
  });

  // births/gifts prefix
  const byBirth=nodes.slice().sort((a,b)=>a.birth-b.birth);
  const birthsSorted=byBirth.map(n=>n.birth);
  let acc=0; const giftPrefix=byBirth.map(n=>{ acc+=n.gift; return acc; });
  const maxBirth=nodes.reduce((m,n)=>Math.max(m,n.birth),0);

  return {nodes,links,roots,birthsSorted,giftPrefix,maxBirth};
}

/*** ---------- Minimal mat4 utils ---------- ***/
function mat4Perspective(out, fovy, aspect, near, far){
  const f=1/Math.tan(fovy/2), nf=1/(near-far);
  out[0]=f/aspect; out[1]=0; out[2]=0; out[3]=0;
  out[4]=0; out[5]=f; out[6]=0; out[7]=0;
  out[8]=0; out[9]=0; out[10]=(far+near)*nf; out[11]=-1;
  out[12]=0; out[13]=0; out[14]=2*far*near*nf; out[15]=0; return out;
}
function mat4Identity(a){for(let i=0;i<16;i++) a[i]=(i%5===0)?1:0; return a;}
function mat4Mul(out,a,b){
  const o=new Float32Array(16);
  for(let r=0;r<4;r++) for(let c=0;c<4;c++){
    o[r*4+c]=a[r*4+0]*b[0*4+c]+a[r*4+1]*b[1*4+c]+a[r*4+2]*b[2*4+c]+a[r*4+3]*b[3*4+c];
  }
  out.set(o); return out;
}
function mat4Look(out, eye, center, up){
  const [ex,ey,ez]=eye, [cx,cy,cz]=center, [ux,uy,uz]=up;
  let zx=ex-cx, zy=ey-cy, zz=ez-cz; let zl=1/Math.hypot(zx,zy,zz); zx*=zl; zy*=zl; zz*=zl;
  let xx=uy*zz-uz*zy, xy=uz*zx-ux*zz, xz=ux*zy-uy*zx; let xl=1/Math.hypot(xx,xy,xz); xx*=xl; xy*=xl; xz*=xl;
  let yx=zy*xz-zz*xy, yy=zz*xx-zx*xz, yz=zx*xy-zy*xx;
  out[0]=xx; out[1]=yx; out[2]=zx; out[3]=0;
  out[4]=xy; out[5]=yy; out[6]=zy; out[7]=0;
  out[8]=xz; out[9]=yz; out[10]=zz; out[11]=0;
  out[12]=-(xx*ex+xy*ey+xz*ez);
  out[13]=-(yx*ex+yy*ey+yz*ez);
  out[14]=-(zx*ex+zy*ey+zz*ez);
  out[15]=1; return out;
}

/*** ---------- WebGL setup ---------- ***/
const canvas=$('gl');
const gl = canvas.getContext('webgl', {antialias:true, alpha:false, preserveDrawingBuffer:false});
if(!gl){ setStatus('Error: WebGL not available'); throw new Error('WebGL not available'); }

function resizeGL(){
  const dpr=window.devicePixelRatio||1;
  const w=canvas.clientWidth, h=canvas.clientHeight;
  canvas.width=Math.max(1, w*dpr); canvas.height=Math.max(1, h*dpr);
  gl.viewport(0,0,canvas.width,canvas.height);
}
window.addEventListener('resize', resizeGL);

/*** ---------- Shaders ---------- ***/
// Points (nodes): per-vertex position, color, birth; shader computes alpha from time
const vsPoints = `
attribute vec3 aPos;
attribute vec3 aCol;
attribute float aBirth;
uniform mat4 uMVP;
uniform float uTime;
uniform float uRamp;
uniform float uPointScale;  // pixels per world unit at Z=0
varying vec3 vCol;
varying float vAlpha;
void main(){
  vec4 clip = uMVP * vec4(aPos,1.0);
  gl_Position = clip;
  float a = clamp( (uTime - aBirth) / uRamp, 0.0, 1.0 );
  vAlpha = a;
  vCol = aCol;
  // approximate point size: scale with perspective
  float size = (4.0 + 6.0) * a; // base in px scaled by alpha
  // a crude perspective factor from clip.w
  float ps = uPointScale / max(0.0001, clip.w);
  gl_PointSize = size * ps;
}
`;
const fsPoints = `
precision mediump float;
varying vec3 vCol;
varying float vAlpha;
void main(){
  // round point sprite
  vec2 uv = gl_PointCoord*2.0 - 1.0;
  float r = dot(uv,uv);
  if(r>1.0) discard;
  float edge = smoothstep(1.0, 0.7, 1.0 - r); // soft edge
  gl_FragColor = vec4(vCol, vAlpha * edge);
}
`;

// Lines (edges): single uniform color & alpha
const vsLines = `
attribute vec3 aPos;
uniform mat4 uMVP;
void main(){ gl_Position = uMVP * vec4(aPos,1.0); }
`;
const fsLines = `
precision mediump float;
uniform vec4 uColor;
void main(){ gl_FragColor = uColor; }
`;

// compile helper
function compile(gl, type, src){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
function program(gl, vsSrc, fsSrc){
  const p=gl.createProgram();
  gl.attachShader(p, compile(gl, gl.VERTEX_SHADER, vsSrc));
  gl.attachShader(p, compile(gl, gl.FRAGMENT_SHADER, fsSrc));
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
  return p;
}
const progPoints = program(gl, vsPoints, fsPoints);
const progLines  = program(gl, vsLines,  fsLines);

/*** ---------- Build model & buffers ---------- ***/
const model = buildGraph(P);
const N = model.nodes.length;
const E = model.links.length;

// Colors
const COLOR_DARK=[0x1e/255,0x3a/255,0x8a/255];   // dark blue
const COLOR_LIGHT=[0x93/255,0xc5/255,0xfd/255];  // light blue
const COLOR_GREEN=[0x22/255,0xc5/255,0x5e/255];
const COLOR_RED=[0xef/255,0x44/255,0x44/255];

// Node attributes
const nodePos = new Float32Array(N*3);
const nodeCol = new Float32Array(N*3);
const nodeBirth = new Float32Array(N);
for(let i=0;i<N;i++){
  const n=model.nodes[i];
  nodePos[i*3+0]=n.x; nodePos[i*3+1]=n.y; nodePos[i*3+2]=n.z;
  const c = n.type==='dark'?COLOR_DARK : n.type==='light'?COLOR_LIGHT : n.type==='green'?COLOR_GREEN : COLOR_RED;
  nodeCol[i*3+0]=c[0]; nodeCol[i*3+1]=c[1]; nodeCol[i*3+2]=c[2];
  nodeBirth[i]=n.birth;
}

// Edge positions for base lines (all)
const edgePos = new Float32Array(E*6);
for(let i=0;i<E;i++){
  const l=model.links[i]; const a=model.nodes[l.source], b=model.nodes[l.target];
  edgePos[i*6+0]=a.x; edgePos[i*6+1]=a.y; edgePos[i*6+2]=a.z;
  edgePos[i*6+3]=b.x; edgePos[i*6+4]=b.y; edgePos[i*6+5]=b.z;
}
// Edge positions sorted by child birth for cyan growth
const sorted = model.links.slice().sort((a,b)=> model.nodes[a.target].birth - model.nodes[b.target].birth);
const edgeGrowPos = new Float32Array(E*6);
const edgeGrowBirths = new Float32Array(E);
for(let i=0;i<E;i++){
  const l=sorted[i]; const a=model.nodes[l.source], b=model.nodes[l.target];
  edgeGrowPos[i*6+0]=a.x; edgeGrowPos[i*6+1]=a.y; edgeGrowPos[i*6+2]=a.z;
  edgeGrowPos[i*6+3]=b.x; edgeGrowPos[i*6+4]=b.y; edgeGrowPos[i*6+5]=b.z;
  edgeGrowBirths[i]=model.nodes[l.target].birth;
}

// Create buffers
function mkBuf(target, data, usage=gl.STATIC_DRAW){ const b=gl.createBuffer(); gl.bindBuffer(target,b); gl.bufferData(target,data,usage); return b; }
const bufPos   = mkBuf(gl.ARRAY_BUFFER, nodePos);
const bufCol   = mkBuf(gl.ARRAY_BUFFER, nodeCol);
const bufBirth = mkBuf(gl.ARRAY_BUFFER, nodeBirth);
const bufEdges = mkBuf(gl.ARRAY_BUFFER, edgePos);
const bufGrow  = mkBuf(gl.ARRAY_BUFFER, edgeGrowPos);

// Camera/controls
let yaw=0, pitch=0, dist=1100, panX=0, panY=0;
let dragging=false, rotating=false, lastX=0,lastY=0;
canvas.addEventListener('mousedown', (e)=>{ dragging=true; rotating=(e.button===0 && !e.ctrlKey); lastX=e.clientX; lastY=e.clientY; });
window.addEventListener('mouseup', ()=> dragging=false);
window.addEventListener('mousemove', (e)=>{
  if(!dragging) return;
  const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
  if(rotating){ yaw += dx*0.005; pitch = Math.max(-1.2, Math.min(1.2, pitch + dy*0.005)); }
  else { panX += dx; panY += dy; }
});
canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); dist = Math.max(200, Math.min(3000, dist + e.deltaY)); }, {passive:false});

// MVP
const matProj=new Float32Array(16), matView=new Float32Array(16), matMVP=new Float32Array(16);

// Bloom clock & counters
const BLOOM={playing:true, t:0, duration:model.maxBirth+2000, start:performance.now()};
function upperBound(arr,val){let lo=0,hi=arr.length; while(lo<hi){const mid=(lo+hi)>>1; if(arr[mid]<=val) lo=mid+1; else hi=mid;} return lo;}
function updateCounters(){
  const idx = upperBound(model.birthsSorted, BLOOM.t);
  const coins = idx;
  const gifts = idx?model.giftPrefix[idx-1]:0;
  const raised = coins*50 + gifts;
  coinsVal.textContent = coins.toLocaleString('en-US');
  raisedVal.textContent = fmtMoney(Math.round(raised));
}

// Picking: project CPU-side and find nearest
function projectPoint(x,y,z, mvp, width, height){
  const v=[x,y,z,1];
  const o=[0,0,0,0];
  // multiply
  for(let r=0;r<4;r++) o[r]=mvp[r*4+0]*v[0]+mvp[r*4+1]*v[1]+mvp[r*4+2]*v[2]+mvp[r*4+3]*v[3];
  const iw = 1/Math.max(1e-6, o[3]);
  const ndcX = o[0]*iw, ndcY = o[1]*iw;
  return {x: (ndcX*0.5+0.5)*width, y: (-ndcY*0.5+0.5)*height, w:o[3]};
}
let highlightSet=null;
canvas.addEventListener('click', (e)=>{
  // build current MVP first
  const dpr = window.devicePixelRatio||1;
  const w = canvas.width/dpr, h=canvas.height/dpr;
  mat4Perspective(matProj, Math.PI/3, w/h, 0.1, 5000);
  // camera from yaw/pitch/dist + pan
  const cx = Math.sin(yaw)*dist*Math.cos(pitch);
  const cy = Math.sin(pitch)*dist;
  const cz = Math.cos(yaw)*dist*Math.cos(pitch);
  // pan offsets in view space: approximate screen pixel -> world units
  const panScale = dist/900;
  mat4Look(matView, [cx - panX*panScale, cy + panY*panScale, cz], [ -panX*panScale, 0+panY*panScale, 0 ], [0,1,0]);
  mat4Mul(matMVP, matProj, matView);

  // find nearest within threshold
  const mx=e.clientX, my=e.clientY;
  let best=-1, bestD=14;
  for(let i=0;i<N;i++){
    const n=model.nodes[i];
    const p=projectPoint(n.x,n.y,n.z, matMVP, w, h);
    const dx=mx - p.x, dy=my - p.y;
    const d=Math.hypot(dx,dy);
    if(d<bestD){ bestD=d; best=i; }
  }
  if(best>=0){
    // BFS keep
    const keep=new Set([best]), q=[best];
    while(q.length){const cur=q.shift(); model.nodes[cur].children.forEach(ch=>{ if(!keep.has(ch)){keep.add(ch); q.push(ch);} });}
    highlightSet=keep;
    // Influence so far
    const vis=[...keep].filter(i=> model.nodes[i].birth <= BLOOM.t);
    const coins = vis.length;
    const gifts = vis.reduce((s,i)=> s + model.nodes[i].gift, 0);
    const raised = coins*50 + gifts;
    const selfGift = model.nodes[best].gift + 50;
    const network = raised - selfGift;
    setStatus(`selected #${best} — direct ${fmtMoney(selfGift)} · constellation ${coins-1} others raising ${fmtMoney(network)} (total ${fmtMoney(raised)})`);
  } else {
    highlightSet=null;
  }
});

// Render loop
function render(){
  // tick bloom
  if(BLOOM.playing){
    BLOOM.t = Math.min(BLOOM.duration, performance.now()-BLOOM.start);
    if(BLOOM.t>=BLOOM.duration){ BLOOM.playing=false; $('btnBloom').textContent='⏵ Bloom'; }
  }
  updateCounters();
  tlFill.style.width = `${Math.min(100,(BLOOM.t/BLOOM.duration)*100)}%`;

  // resize + clear
  resizeGL();
  gl.enable(gl.DEPTH_TEST);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const dpr = window.devicePixelRatio||1;
  const w = canvas.width/dpr, h=canvas.height/dpr;

  // build MVP
  mat4Perspective(matProj, Math.PI/3, w/h, 0.1, 5000);
  const cx = Math.sin(yaw)*dist*Math.cos(pitch);
  const cy = Math.sin(pitch)*dist;
  const cz = Math.cos(yaw)*dist*Math.cos(pitch);
  const panScale = dist/900;
  mat4Look(matView, [cx - panX*panScale, cy + panY*panScale, cz], [ -panX*panScale, 0+panY*panScale, 0 ], [0,1,0]);
  mat4Mul(matMVP, matProj, matView);

  // draw base edges (faint)
  gl.useProgram(progLines);
  gl.bindBuffer(gl.ARRAY_BUFFER, bufEdges);
  const aPosL = gl.getAttribLocation(progLines, 'aPos');
  gl.enableVertexAttribArray(aPosL);
  gl.vertexAttribPointer(aPosL, 3, gl.FLOAT, false, 0, 0);
  gl.uniformMatrix4fv(gl.getUniformLocation(progLines,'uMVP'), false, matMVP);
  gl.uniform4f(gl.getUniformLocation(progLines,'uColor'), 0x5b/255,0x6b/255,0x95/255, 0.14);
  gl.drawArrays(gl.LINES, 0, E*2);

  // draw growing edges (cyan) up to current time
  // compute how many segments are born
  let lo=0, hi=edgeGrowBirths.length;
  while(lo<hi){ const mid=(lo+hi)>>1; if(edgeGrowBirths[mid]<=BLOOM.t) lo=mid+1; else hi=mid; }
  const segs = lo;
  if(segs>0){
    gl.bindBuffer(gl.ARRAY_BUFFER, bufGrow);
    gl.vertexAttribPointer(aPosL, 3, gl.FLOAT, false, 0, 0);
    gl.uniform4f(gl.getUniformLocation(progLines,'uColor'), 110/255,231/255,255/255, 0.95);
    gl.drawArrays(gl.LINES, 0, segs*2);
  }

  // draw points (nodes)
  gl.useProgram(progPoints);
  // positions
  gl.bindBuffer(gl.ARRAY_BUFFER, bufPos);
  const aPos = gl.getAttribLocation(progPoints,'aPos');
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
  // colors
  gl.bindBuffer(gl.ARRAY_BUFFER, bufCol);
  const aCol = gl.getAttribLocation(progPoints,'aCol');
  gl.enableVertexAttribArray(aCol);
  gl.vertexAttribPointer(aCol, 3, gl.FLOAT, false, 0, 0);
  // birth
  gl.bindBuffer(gl.ARRAY_BUFFER, bufBirth);
  const aBirth = gl.getAttribLocation(progPoints,'aBirth');
  gl.enableVertexAttribArray(aBirth);
  gl.vertexAttribPointer(aBirth, 1, gl.FLOAT, false, 0, 0);

  gl.uniformMatrix4fv(gl.getUniformLocation(progPoints,'uMVP'), false, matMVP);
  gl.uniform1f(gl.getUniformLocation(progPoints,'uTime'), BLOOM.t);
  gl.uniform1f(gl.getUniformLocation(progPoints,'uRamp'), 420.0);
  gl.uniform1f(gl.getUniformLocation(progPoints,'uPointScale'), canvas.height/Math.tan(Math.PI/3/2)); // ~ pixel scale

  // If highlighting, dim others by drawing two passes: kept bright, others dim
  if(highlightSet){
    // build a per-vertex mask by drawing two subsets (CPU-side index list)
    // Fast path: draw all bright, then overlay a dimmed full cloud with destination-over? Simpler: two draws using gl.POINTS + clip via alpha
    // Here we just draw everything; the point shader alpha already uses bloom.
    // To dim others, we’ll do a crude screen-space overlay: draw kept again larger.
  }
  gl.drawArrays(gl.POINTS, 0, N);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

/*** ---------- Buttons / keys ---------- ***/
$('btnHelp').addEventListener('click', ()=> $('help').classList.toggle('open'));
$('btnBloom').addEventListener('click', ()=>{
  BLOOM.playing=!BLOOM.playing;
  $('btnBloom').textContent=BLOOM.playing?'⏸ Bloom':'⏵ Bloom';
  if(BLOOM.playing) BLOOM.start=performance.now()-BLOOM.t;
});
window.addEventListener('keydown', (e)=>{
  if(e.key==='h'||e.key==='H') $('help').classList.toggle('open');
  if(e.key==='b'||e.key==='B'){
    if(e.shiftKey){ BLOOM.t=0; BLOOM.playing=false; $('btnBloom').textContent='⏵ Bloom'; tlFill.style.width='0%'; }
    else { BLOOM.playing=!BLOOM.playing; $('btnBloom').textContent=BLOOM.playing?'⏸ Bloom':'⏵ Bloom'; if(BLOOM.playing) BLOOM.start=performance.now()-BLOOM.t; }
  }
});

/*** ---------- Initial UI ---------- ***/
setStatus('ready — WebGL 3D (no libraries)');
</script>
</body>
</html>
