<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Smart Coin® — 3D Donor Dedication Map</title>
<style>
  /* Dark theme */
  :root{
    --bg:#000000; --panel:#121a36; --text:#eaf0ff; --muted:#9aa3c9; --border:#1f2a4d;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #app{position:relative;width:100%;height:100vh;min-height:560px;background:#000}

  #status{
    position:fixed;left:10px;bottom:10px;z-index:10;
    background:var(--panel);color:var(--muted);
    border:1px solid var(--border);border-radius:8px;
    padding:6px 10px;font-size:12px;max-width:80vw;white-space:pre-wrap
  }
  #legend{
    position:fixed;left:10px;top:10px;z-index:10;background:var(--panel);
    border:1px solid var(--border);border-radius:8px;padding:8px 10px;
    font-size:12px;color:#cfe1ff
  }
  .chip{display:inline-block;width:10px;height:10px;border-radius:50%;
    margin-right:6px;vertical-align:middle;border:1px solid #2f3b66}

  /* Controls panel (top-right) */
  #ui{
    position:fixed;right:10px;top:10px;z-index:11;background:var(--panel);
    border:1px solid var(--border);border-radius:8px;padding:10px 12px;
    font-size:12px;color:#eaf0ff;min-width:280px;max-width:46ch
  }
  #ui h3{margin:0 0 8px 0;font-size:13px}
  #ui h4{margin:12px 0 6px 0;font-size:12px;color:#cfe1ff}
  #ui .row{display:flex;align-items:center;gap:8px;margin:8px 0}
  #ui label{width:150px}
  #ui input[type="range"]{flex:1}
  #ui output{width:52px;text-align:right;display:inline-block}
  #ui .btns{display:flex;gap:8px;margin-top:8px}
  #ui button{
    cursor:pointer;border:1px solid var(--border);background:#0b1020;color:#eaf0ff;border-radius:6px;
    padding:6px 10px;font-size:12px
  }
  #metrics{margin-top:10px;border-top:1px solid var(--border);padding-top:8px;line-height:1.4}
  #metrics b{font-weight:600}
  input[type="range"]{accent-color:#6ee7ff}
</style>

<script src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.min.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>

<body>
<div id="app"></div>

<div id="legend">
  <div><span class="chip" style="background:#1e3a8a"></span>Dark blue: initial donors (roots)</div>
  <div><span class="chip" style="background:#93c5fd"></span>Light blue: referrals (+1 branching)</div>
  <div><span class="chip" style="background:#22c55e"></span>Green: extra branch seed</div>
  <div><span class="chip" style="background:#ef4444"></span>Red: downstream from extras</div>
  <div style="margin-top:6px"><span class="chip" style="background:#06b6d4"></span>Highlight: descendants &nbsp; <span class="chip" style="background:#f59e0b"></span>Highlight: ancestor path</div>
</div>

<!-- Control panel -->
<div id="ui">
  <h3>Donor Map Controls</h3>
  <div class="row">
    <label for="donors">Initial donors</label>
    <input id="donors" type="range" min="10" max="400" value="80">
    <output id="donorsOut">80</output>
  </div>

  <h4>+1 Branching (light)</h4>
  <div class="row">
    <label for="plusDepth">Max depth</label>
    <input id="plusDepth" type="range" min="1" max="30" value="10">
    <output id="plusDepthOut">10</output>
  </div>
  <div class="row">
    <label for="plusProb">Continue prob.</label>
    <input id="plusProb" type="range" min="0" max="1" step="0.01" value="0.85">
    <output id="plusProbOut">0.85</output>
  </div>
  <div class="row">
    <label for="plusFanout">Avg referrals</label>
    <input id="plusFanout" type="range" min="0" max="5" step="0.1" value="1.6">
    <output id="plusFanoutOut">1.6</output>
  </div>
  <div class="row">
    <label for="plusDecay">Depth decay</label>
    <input id="plusDecay" type="range" min="0" max="1" step="0.01" value="0.90">
    <output id="plusDecayOut">0.90</output>
  </div>

  <h4>Extra Branch (green → red)</h4>
  <div class="row">
    <label for="extra">Seed prob./root</label>
    <input id="extra" type="range" min="0" max="1" step="0.01" value="0.30">
    <output id="extraOut">0.30</output>
  </div>
  <div class="row">
    <label for="extraDepth">Max depth</label>
    <input id="extraDepth" type="range" min="0" max="20" value="8">
    <output id="extraDepthOut">8</output>
  </div>
  <div class="row">
    <label for="extraProb">Continue prob.</label>
    <input id="extraProb" type="range" min="0" max="1" step="0.01" value="0.75">
    <output id="extraProbOut">0.75</output>
  </div>
  <div class="row">
    <label for="extraFanout">Avg referrals</label>
    <input id="extraFanout" type="range" min="0" max="4" step="0.1" value="2.0">
    <output id="extraFanoutOut">2.0</output>
  </div>
  <div class="row">
    <label for="extraDecay">Depth decay</label>
    <input id="extraDecay" type="range" min="0" max="1" step="0.01" value="0.85">
    <output id="extraDecayOut">0.85</output>
  </div>

  <h4>Layout</h4>
  <div class="row">
    <label for="radius">Sphere radius</label>
    <input id="radius" type="range" min="100" max="1200" value="380">
    <output id="radiusOut">380</output>
  </div>
  <div class="row">
    <label for="jitter">Child jitter</label>
    <input id="jitter" type="range" min="2" max="120" value="36">
    <output id="jitterOut">36</output>
  </div>
  <div class="row">
    <label for="seed">Seed</label>
    <input id="seed" type="text" placeholder="random" style="flex:1" />
  </div>
  <div class="row">
    <label for="cap">Max nodes cap</label>
    <input id="cap" type="range" min="1000" max="20000" step="500" value="8000">
    <output id="capOut">8000</output>
  </div>

  <h4>Highlight</h4>
  <div class="row">
    <label for="showAnc">Show ancestors</label>
    <input id="showAnc" type="checkbox" checked />
  </div>
  <div class="row">
    <label for="ancCap">Ancestor depth cap</label>
    <input id="ancCap" type="range" min="0" max="50" value="0">
    <output id="ancCapOut">∞</output>
  </div>

  <div class="row">
    <label for="auto">Auto rebuild</label>
    <input id="auto" type="checkbox" checked />
  </div>

  <div class="btns">
    <button id="rebuildBtn" type="button">Rebuild</button>
    <button id="resetViewBtn" type="button">Reset view</button>
    <button id="clearHiBtn" type="button">Clear highlight</button>
  </div>

  <div id="metrics"></div>
</div>

<div id="status">Status: loading…</div>

<script type="module">
const statusEl = document.getElementById('status');
const setStatus = (m)=> statusEl.textContent = 'Status: ' + m;
const showError = (e)=>{ setStatus('Error: ' + (e?.message||e)); console.error(e); };

const root = document.getElementById('app');

try {
  setStatus('loading modules…');
  const THREE = await import('three');
  const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');

  // ---- renderer/scene/camera ----
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  renderer.domElement.style.touchAction = 'none';
  root.appendChild(renderer.domElement);
  renderer.setClearColor(0x000000, 1);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000); // black

  const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 5000);
  function resetView(){
    camera.position.set(0, 0, 760);
    controls.target.set(0, 0, 0);
    controls.update();
  }

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.05;

  scene.add(new THREE.AmbientLight(0xffffff, 0.9));
  const dir = new THREE.DirectionalLight(0xffffff, 0.55); dir.position.set(300,500,400); scene.add(dir);

  function sizeOf(el){
    const w = el.clientWidth || el.parentElement?.clientWidth || window.innerWidth;
    const h = el.clientHeight || el.parentElement?.clientHeight || Math.round(window.innerHeight*0.7);
    return {w: Math.max(1,w), h: Math.max(1,h)};
  }
  function resize(){
    const {w,h} = sizeOf(root);
    camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false);
  }
  window.addEventListener('resize', resize);
  if ('ResizeObserver' in window) new ResizeObserver(resize).observe(root);
  resetView(); resize();

  // ---- interactive state ----
  const state = {
    group:null, nodes:[], links:[], spheres:[], edges:null,
    glowDesc:null, glowAnc:null, rootWire:null,
    levels:[], roots:[], capped:false
  };

  // seedable RNG
  function xmur3(str){ for(var i=0,h=1779033703^str.length;i<str.length;i++) h=Math.imul(h^str.charCodeAt(i),3432918353),h=h<<13|h>>>19; return function(){ h=Math.imul(h^ (h>>>16), 2246822507); h=Math.imul(h^ (h>>>13), 3266489909); return (h^ (h>>>16))>>>0; } }
  function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15, t|1); t^=t+Math.imul(t^t>>>7, t|61); return ((t^t>>>14)>>>0)/4294967296; } }
  function makeRNG(seedStr){
    if(!seedStr) return Math.random;
    const seed = xmur3(String(seedStr))();
    return mulberry32(seed);
  }
  // Poisson sampler (Knuth)
  function poisson(lambda, rand){
    if(lambda<=0) return 0;
    const L = Math.exp(-lambda);
    let k=0, p=1;
    do { k++; p *= rand(); } while(p > L);
    return k-1;
  }

  // dispose helper
  function dispose(obj){
    obj.traverse(o=>{
      if(o.geometry) o.geometry.dispose();
      if(o.material){
        if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose());
        else o.material.dispose();
      }
    });
  }
  function clearHi(){
    if(state.glowDesc){ state.group.remove(state.glowDesc); dispose(state.glowDesc); state.glowDesc=null; }
    if(state.glowAnc){ state.group.remove(state.glowAnc); dispose(state.glowAnc); state.glowAnc=null; }
    if(state.rootWire){ state.group.remove(state.rootWire); dispose(state.rootWire); state.rootWire=null; }
    state.spheres.forEach(m=>{ m.material.transparent=false; m.material.opacity=1; });
    if(state.edges) state.edges.material.opacity=0.35;
  }

  // build / rebuild graph (with branching)
  function buildGraph(params){
    const {
      initialDonors=80,
      plusDepth=10, plusProb=0.85, plusFanout=1.6, plusDecay=0.90,
      extraProbRoot=0.30, extraDepth=8, extraContProb=0.75, extraFanout=2.0, extraDecay=0.85,
      sphereRadius=380, childJitter=36, seed='', nodeCap=8000
    } = params;

    // clean previous
    if(state.group){ scene.remove(state.group); dispose(state.group); }
    state.group = new THREE.Group(); scene.add(state.group);
    state.nodes=[]; state.links=[]; state.spheres=[]; state.edges=null; state.roots=[];
    clearHi();
    state.capped=false;

    const rand = makeRNG(seed);

    const COLOR_DARK=0x1e3a8a, COLOR_LIGHT=0x93c5fd, COLOR_GREEN=0x22c55e, COLOR_RED=0xef4444;
    const COLOR_EDGE=0x5b6b95;

    let id=0;
    function addNode(type,parent=null,depth=0){
      if(state.nodes.length >= nodeCap){ state.capped=true; return null; }
      const n={id:id++,type,parent,children:[],depth};
      state.nodes.push(n);
      if(parent!=null){
        state.links.push({source:parent,target:n.id});
        state.nodes[parent].children.push(n.id);
      }
      return n;
    }

    // roots
    for(let i=0;i<initialDonors;i++){ const r = addNode('dark', null, 0); if(r) state.roots.push(r.id); if(state.capped) break; }

    // --- Branching helper (BFS) ---
    function growBranchingFrom(parentIds, nodeType, maxDepth, contProb, avgFanout, decay){
      const q=[];
      // UPDATED: seed each parent with k0 = max(1, Poisson(avgFanout)) children (depth=1)
      for(const pid of parentIds){
        if(state.capped) break;
        const k0 = Math.max(1, poisson(Math.max(0, avgFanout), rand));
        for(let i=0;i<k0 && !state.capped;i++){
          const child = addNode(nodeType, pid, 1);
          if(child) q.push({id:child.id, depth:1});
        }
      }

      // BFS expansion for deeper levels
      while(q.length && !state.capped){
        const {id:pid, depth} = q.shift();
        if(depth >= maxDepth) continue;

        const scale = Math.pow(decay, Math.max(0, depth-1)); // depth 1 => 1.0
        if(rand() >= contProb * scale) continue;

        const lam = Math.max(0, avgFanout * scale);
        let k = poisson(lam, rand); // number of children to spawn
        while(k-- > 0 && !state.capped){
          const child = addNode(nodeType, pid, depth+1);
          if(child) q.push({id:child.id, depth:depth+1});
        }
      }
    }

    // per-root growth
    // Light referrals (branching)
    const rootIds = state.roots.slice();
    growBranchingFrom(rootIds, 'light', plusDepth, plusProb, plusFanout, plusDecay);

    // Extra branch (green seed + red branching)
    for(const r of rootIds){
      if(state.capped) break;
      if(rand() < extraProbRoot){
        const g = addNode('green', r, 1);
        if(g){
          // Red branching from green — multiple red children possible at depth 1
          growBranchingFrom([g.id], 'red', extraDepth, extraContProb, extraFanout, extraDecay);
        }
      }
    }

    // layout
    function fibSphere(n,r=sphereRadius){
      const pts=[], phi=Math.PI*(3-Math.sqrt(5));
      for(let i=0;i<n;i++){
        const y=1-(i/Math.max(1,n-1))*2;
        const rad=Math.sqrt(Math.max(0,1-y*y));
        const th=phi*i;
        pts.push(new THREE.Vector3(Math.cos(th)*rad*r, y*r, Math.sin(th)*rad*r));
      }
      return pts;
    }
    const darkNodes = state.nodes.filter(n=>n.type==='dark');
    const pts = fibSphere(darkNodes.length, sphereRadius);
    darkNodes.forEach((n,i)=>{ n.x=pts[i].x; n.y=pts[i].y; n.z=pts[i].z; });
    state.nodes.forEach(n=>{
      if(n.type!=='dark'){
        const p = state.nodes[n.parent] || {x:0,y:0,z:0};
        const depthScale = 1 + 0.03 * Math.max(0, (n.depth||1)-1); // slight spread with depth
        const j = ()=> (rand()*2-1)*childJitter*depthScale;
        n.x = p.x + j(); n.y = p.y + j(); n.z = p.z + j();
      }
    });

    // draw nodes
    const col = (t)=> t==='dark'?COLOR_DARK : t==='light'?COLOR_LIGHT : t==='green'?COLOR_GREEN : COLOR_RED;
    state.nodes.forEach(n=>{
      const size = n.type==='dark'?5.2 : n.type==='light'?4 : n.type==='green'?4.4 : 3.8;
      const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(size,18,18),
        new THREE.MeshStandardMaterial({color:col(n.type),metalness:0.15,roughness:0.45})
      );
      mesh.position.set(n.x,n.y,n.z); mesh.userData.id=n.id;
      state.group.add(mesh); state.spheres.push(mesh);
    });

    // draw edges
    const pos = new Float32Array(state.links.length*6); let k=0;
    state.links.forEach(l=>{
      const s=state.nodes[l.source], t=state.nodes[l.target];
      pos[k++]=s.x; pos[k++]=s.y; pos[k++]=s.z; pos[k++]=t.x; pos[k++]=t.y; pos[k++]=t.z;
    });
    const edgeGeo=new THREE.BufferGeometry(); edgeGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    state.edges=new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({color:0x5b6b95,transparent:true,opacity:0.35}));
    state.group.add(state.edges);

    // metrics
    computeLevelsAndMetrics();
    updateMetricsUI(nodeCap);
  }

  function computeLevelsAndMetrics(){
    state.levels = new Array(state.nodes.length).fill(-1);
    let maxDepth = 0;
    state.roots.forEach(rootId=>{
      const q=[rootId]; state.levels[rootId]=0;
      while(q.length){
        const cur=q.shift();
        const lvl = state.levels[cur];
        maxDepth = Math.max(maxDepth, lvl);
        state.nodes[cur].children.forEach(ch=>{
          if(state.levels[ch]===-1){ state.levels[ch]=lvl+1; q.push(ch); }
        });
      }
    });
    state.maxObservedDepth = maxDepth;
    state.totalNodes = state.nodes.length;
    state.totalLinks = state.links.length;
    state.leafCount = state.nodes.filter(n=>n.children.length===0).length;
    state.avgChildrenAtRoot = state.roots.reduce((acc,r)=>acc+state.nodes[r].children.length,0)/Math.max(1,state.roots.length);

    function longestLightChainFrom(rootId){
      const children = state.nodes[rootId].children;
      let best=0;
      for(const ch of children){
        if(state.nodes[ch].type!=='light') continue;
        let len=1, cur=ch;
        while(true){
          const next = state.nodes[cur].children.find(id=>state.nodes[id].type==='light');
          if(next!=null){ len++; cur=next; } else break;
        }
        if(len>best) best=len;
      }
      return best;
    }
    state.longestLightChain = state.roots.reduce((m,r)=>Math.max(m, longestLightChainFrom(r)), 0);
  }

  // ancestry helpers
  function rootOf(id){
    let cur = id, steps=0;
    while(state.nodes[cur].parent!=null){ cur = state.nodes[cur].parent; steps++; }
    return {root:cur, steps};
  }
  function buildAncestorPathLines(startId, cap){
    const maxSegs = (cap===0)? 1e9 : cap;
    let child = startId, segs = []; let used = 0;
    while(state.nodes[child].parent!=null && used < maxSegs){
      const parent = state.nodes[child].parent;
      segs.push([parent, child]);
      child = parent; used++;
    }
    const gpos=new Float32Array(segs.length*6); let i=0;
    segs.forEach(([a,b])=>{
      const s=state.nodes[a], t=state.nodes[b];
      gpos[i++]=s.x; gpos[i++]=s.y; gpos[i++]=s.z; gpos[i++]=t.x; gpos[i++]=t.y; gpos[i++]=t.z;
    });
    return {positions:gpos, segCount:segs.length};
  }

  // highlight logic (click/tap)
  const ray=new THREE.Raycaster(), mouse=new THREE.Vector2();
  let down={x:0,y:0}, moved=false;
  renderer.domElement.addEventListener('pointerdown', (ev)=>{ down.x=ev.clientX; down.y=ev.clientY; moved=false; });
  renderer.domElement.addEventListener('pointermove', (ev)=>{
    if(Math.hypot(ev.clientX-down.x, ev.clientY-down.y) > 6) moved=true;
  });
  renderer.domElement.addEventListener('pointerup', (ev)=>{
    if(moved) return;
    const rect=renderer.domElement.getBoundingClientRect();
    const px=(ev.clientX-rect.left)/rect.width;
    const py=(ev.clientY-rect.top)/rect.height;
    mouse.x=px*2-1; mouse.y=-(py*2-1);
    ray.setFromCamera(mouse,camera);
    const hits=ray.intersectObjects(state.spheres,true);
    if(hits.length){ const id=hits[0].object.userData.id; highlight(id); }
    else { clearHi(); setStatus('donor map ready — rotate/zoom, click/tap to explore'); }
  }, {passive:true});

  function highlight(startId){
    clearHi();

    // Descendants (BFS)
    const keepDesc=new Set([startId]), q=[{id:startId, lvl:0}], perLevel=[];
    while(q.length){
      const {id,lvl} = q.shift();
      perLevel[lvl] = (perLevel[lvl]||0)+1;
      state.nodes[id].children.forEach(ch=>{
        if(!keepDesc.has(ch)){ keepDesc.add(ch); q.push({id:ch,lvl:lvl+1}); }
      });
    }

    // Ancestors
    const showAnc = document.getElementById('showAnc').checked;
    const ancCap = parseInt(document.getElementById('ancCap').value || '0', 10); // 0=∞
    const {root:rootId, steps:stepsToRoot} = rootOf(startId);
    const keepAnc = new Set();
    if(showAnc){
      let cur = startId; let used=0;
      while(state.nodes[cur].parent!=null && (ancCap===0 || used<ancCap)){
        const p = state.nodes[cur].parent;
        keepAnc.add(p); cur = p; used++;
      }
    }

    // dim others, keep descendants + ancestors bright
    const keepAll = new Set([...keepDesc, ...keepAnc]);
    state.spheres.forEach(m=>{
      const on = keepAll.has(m.userData.id);
      m.material.transparent = true;
      m.material.opacity = on ? 1 : 0.12;
    });
    if(state.edges) state.edges.material.opacity=0.08;

    // bright lines: descendants (cyan)
    const keptLinks = state.links.filter(l=> keepDesc.has(l.source) && keepDesc.has(l.target));
    const dpos=new Float32Array(keptLinks.length*6); let i=0;
    keptLinks.forEach(l=>{
      const s=state.nodes[l.source], t=state.nodes[l.target];
      dpos[i++]=s.x; dpos[i++]=s.y; dpos[i++]=s.z; dpos[i++]=t.x; dpos[i++]=t.y; dpos[i++]=t.z;
    });
    const dgeo=new THREE.BufferGeometry(); dgeo.setAttribute('position', new THREE.BufferAttribute(dpos,3));
    state.glowDesc=new THREE.LineSegments(dgeo, new THREE.LineBasicMaterial({color:0x06b6d4, transparent:true, opacity:0.95}));
    state.group.add(state.glowDesc);

    // bright lines: ancestor path (gold)
    if(showAnc){
      const {positions:apos, segCount} = buildAncestorPathLines(startId, ancCap);
      if(segCount>0){
        const ageo=new THREE.BufferGeometry(); ageo.setAttribute('position', new THREE.BufferAttribute(apos,3));
        state.glowAnc=new THREE.LineSegments(ageo, new THREE.LineBasicMaterial({color:0xf59e0b, transparent:true, opacity:0.95}));
        state.group.add(state.glowAnc);
      }
      // ring the true root
      const r = state.nodes[rootId];
      const wire = new THREE.WireframeGeometry(new THREE.SphereGeometry(6.6, 10, 8));
      state.rootWire = new THREE.LineSegments(wire, new THREE.LineBasicMaterial({color:0xf59e0b, transparent:true, opacity:0.85}));
      state.rootWire.position.set(r.x, r.y, r.z);
      state.group.add(state.rootWire);
    }

    const subtreeSize = keepDesc.size;
    const depthDesc = perLevel.length-1;
    const leavesDesc = [...keepDesc].filter(i=> state.nodes[i].children.length===0).length;
    setStatus(`selected #${startId} — descendants: size ${subtreeSize}, depth ${depthDesc}, leaves ${leavesDesc} | steps to root: ${stepsToRoot}${(ancCap>0&&stepsToRoot>ancCap)?' (showing '+ancCap+')':''}`);
  }

  // animation loop
  function loop(){ controls.update(); renderer.render(scene,camera); requestAnimationFrame(loop); }
  loop();

  // ---- UI wiring ----
  const $ = (id)=> document.getElementById(id);
  const donors=$('donors'), donorsOut=$('donorsOut');
  const plusDepth=$('plusDepth'), plusDepthOut=$('plusDepthOut');
  const plusProb=$('plusProb'), plusProbOut=$('plusProbOut');
  const plusFanout=$('plusFanout'), plusFanoutOut=$('plusFanoutOut');
  const plusDecay=$('plusDecay'), plusDecayOut=$('plusDecayOut');

  const extra=$('extra'), extraOut=$('extraOut');
  const extraDepth=$('extraDepth'), extraDepthOut=$('extraDepthOut');
  const extraProb=$('extraProb'), extraProbOut=$('extraProbOut');
  const extraFanout=$('extraFanout'), extraFanoutOut=$('extraFanoutOut');
  const extraDecay=$('extraDecay'), extraDecayOut=$('extraDecayOut');

  const radius=$('radius'), radiusOut=$('radiusOut');
  const jitter=$('jitter'), jitterOut=$('jitterOut');
  const seed=$('seed');
  const cap=$('cap'), capOut=$('capOut');

  const showAnc=$('showAnc'), ancCap=$('ancCap'), ancCapOut=$('ancCapOut');
  const auto=$('auto');
  const rebuildBtn=$('rebuildBtn'), resetViewBtn=$('resetViewBtn'), clearHiBtn=$('clearHiBtn');
  const metricsDiv = $('metrics');

  function syncOutputs(){
    donorsOut.textContent=donors.value;
    plusDepthOut.textContent=plusDepth.value;
    plusProbOut.textContent=Number(plusProb.value).toFixed(2);
    plusFanoutOut.textContent=Number(plusFanout.value).toFixed(1);
    plusDecayOut.textContent=Number(plusDecay.value).toFixed(2);

    extraOut.textContent=Number(extra.value).toFixed(2);
    extraDepthOut.textContent=extraDepth.value;
    extraProbOut.textContent=Number(extraProb.value).toFixed(2);
    extraFanoutOut.textContent=Number(extraFanout.value).toFixed(1);
    extraDecayOut.textContent=Number(extraDecay.value).toFixed(2);

    radiusOut.textContent=radius.value;
    jitterOut.textContent=jitter.value;
    capOut.textContent=cap.value;
    ancCapOut.textContent = (parseInt(ancCap.value,10)===0) ? '∞' : ancCap.value;
  }
  function getParams(){
    return {
      initialDonors: parseInt(donors.value,10),
      plusDepth: parseInt(plusDepth.value,10),
      plusProb: clamp01(parseFloat(plusProb.value)),
      plusFanout: Math.max(0, parseFloat(plusFanout.value)),
      plusDecay: clamp01(parseFloat(plusDecay.value)),
      extraProbRoot: clamp01(parseFloat(extra.value)),
      extraDepth: parseInt(extraDepth.value,10),
      extraContProb: clamp01(parseFloat(extraProb.value)),
      extraFanout: Math.max(0, parseFloat(extraFanout.value)),
      extraDecay: clamp01(parseFloat(extraDecay.value)),
      sphereRadius: parseInt(radius.value,10),
      childJitter: parseInt(jitter.value,10),
      seed: (seed.value || '').trim(),
      nodeCap: parseInt(cap.value,10)
    };
  }
  function clamp01(x){ return isFinite(x) ? Math.max(0, Math.min(1, x)) : 0; }

  function updateMetricsUI(nodeCap){
    const m = {
      roots: state.roots.length,
      nodes: state.totalNodes,
      links: state.totalLinks,
      maxDepth: state.maxObservedDepth,
      leaves: state.leafCount,
      avgChildrenAtRoot: state.avgChildrenAtRoot,
      longestLightChain: state.longestLightChain,
      capped: state.capped
    };
    metricsDiv.innerHTML =
      `<div><b>Roots:</b> ${m.roots} &nbsp; <b>Nodes:</b> ${m.nodes} &nbsp; <b>Links:</b> ${m.links}</div>
       <div><b>Max depth (global):</b> ${m.maxDepth} &nbsp; <b>Leaves:</b> ${m.leaves}</div>
       <div><b>Avg children/root:</b> ${m.avgChildrenAtRoot.toFixed(2)} &nbsp; <b>Longest +1 chain:</b> ${m.longestLightChain}</div>
       <div><b>Node cap:</b> ${nodeCap} &nbsp; <b>Capped:</b> ${m.capped ? 'Yes' : 'No'}</div>`;
  }

  let debounceTimer=null;
  function scheduleRebuild(){
    if(!auto.checked) return;
    clearTimeout(debounceTimer);
    debounceTimer=setTimeout(()=>{ setStatus('rebuilding…'); buildGraph(getParams()); setStatus('donor map ready — rotate/zoom, click/tap to explore'); }, 150);
  }

  [donors,plusDepth,plusProb,plusFanout,plusDecay,
   extra,extraDepth,extraProb,extraFanout,extraDecay,
   radius,jitter,seed,cap].forEach(el=>{
    el.addEventListener('input', ()=>{ syncOutputs(); scheduleRebuild(); });
    el.addEventListener('change', ()=>{ syncOutputs(); scheduleRebuild(); });
  });
  [showAnc, ancCap].forEach(el=>{
    el.addEventListener('input', ()=> syncOutputs());
    el.addEventListener('change', ()=> syncOutputs());
  });

  rebuildBtn.addEventListener('click', ()=>{
    setStatus('rebuilding…'); buildGraph(getParams());
    setStatus('donor map ready — rotate/zoom, click/tap to explore');
  });
  resetViewBtn.addEventListener('click', ()=> resetView());
  clearHiBtn.addEventListener('click', ()=> { clearHi(); setStatus('donor map ready — rotate/zoom, click/tap to explore'); });

  // initial build
  syncOutputs();
  buildGraph(getParams());
  setStatus('donor map ready — rotate/zoom, click/tap to explore');

} catch(err) {
  showError(err);
}
</script>
</body>
</html>
