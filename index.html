<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Smart Coin™ — Donor Universe (Bloom + Live Totals, 3D with 2D fallback)</title>
<style>
  :root{ --bg:#000; --panel:#111826; --text:#eaf0ff; --muted:#9aa3c9; --border:#1f2a4d; --accent:#6ee7ff; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #app{position:relative;width:100%;height:100vh;min-height:560px;background:#000;overflow:hidden}

  .chip{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:middle;border:1px solid #2f3b66}
  #legend{position:fixed;left:10px;top:10px;z-index:8;background:var(--panel);border:1px solid var(--border);border-radius:8px;padding:6px 8px;font-size:12px;color:#cfe1ff;opacity:.92}
  #status{position:fixed;left:10px;bottom:10px;z-index:8;background:var(--panel);color:var(--muted);border:1px solid var(--border);border-radius:8px;padding:6px 10px;font-size:12px;max-width:78vw;white-space:pre-wrap}

  #counters{position:fixed;left:50%;top:10px;transform:translateX(-50%);z-index:9;display:flex;gap:10px}
  .pill{background:var(--panel);border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:13px;opacity:.96}
  .pill b{font-weight:700}

  #buttons{position:fixed;right:10px;top:10px;z-index:9;display:flex;gap:8px}
  .btn{background:var(--panel);color:#eaf0ff;border:1px solid var(--border);border-radius:999px;padding:8px 10px;font-size:12px;cursor:pointer}

  #help{position:fixed;right:10px;top:44px;z-index:10;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:10px 12px;font-size:12px;display:none;max-width:360px}
  #help.open{display:block}

  #tip{position:fixed;pointer-events:none;z-index:11;background:#0b1020;border:1px solid #223054;border-radius:6px;padding:6px 8px;font-size:12px;display:none;color:#dce6ff}

  #timeline{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);z-index:9;width:min(520px,70vw);height:8px;background:var(--panel);border:1px solid var(--border);border-radius:999px;overflow:hidden;box-shadow:0 2px 10px rgba(0,0,0,.25)}
  #tlFill{height:100%;width:0%;background:var(--accent);opacity:.95}

  @media (max-width:768px){
    #legend{font-size:11px}
    #counters{top:auto;bottom:38px}
  }
</style>
</head>
<body>
<div id="app"></div>

<div id="legend">
  <div><span class="chip" style="background:#1e3a8a"></span>Dark blue: roots</div>
  <div><span class="chip" style="background:#93c5fd"></span>Light blue: primary +1 (max 1 per parent)</div>
  <div><span class="chip" style="background:#22c55e"></span>Green: extras (other donations)</div>
  <div><span class="chip" style="background:#ef4444"></span>Red: everything below any green</div>
</div>

<div id="counters">
  <div class="pill">Coins: <b id="coinsVal">0</b></div>
  <div class="pill">Raised: <b id="raisedVal">$0</b></div>
</div>

<div id="buttons">
  <button id="btnBloom" class="btn">⏵ Bloom</button>
  <button id="btnHelp" class="btn">?</button>
</div>
<div id="help">
  <b>Shortcuts</b><br>
  B — play/pause Bloom ・ Shift+B — restart<br>
  Click a node to highlight its constellation + influence so far.<br>
  Counters show <i>coins sold</i> (1 per node) and <i>total raised</i> = coins×$50 + gifts.<br>
  If 3D libraries can’t load, this page auto‑switches to a fast 2D fallback.
</div>

<div id="tip"></div>
<div id="timeline" aria-hidden="true"><div id="tlFill"></div></div>
<div id="status">Status: loading…</div>

<!-- (Optional) Try to load global Three.js + OrbitControls.
     If the network blocks these, the code below will switch to 2D automatically. -->
<script>
(function(){
  const statusEl=document.getElementById('status');
  const setStatus=(m)=>statusEl.textContent='Status: '+m;

  // --- Utilities shared by both renderers ---
  const $=(id)=>document.getElementById(id);
  const tipEl=$('tip'), tlFill=$('tlFill'), coinsVal=$('coinsVal'), raisedVal=$('raisedVal'), helpEl=$('help');
  const fmtMoney=(n)=> n.toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
  const easeOutCubic=t=>1-Math.pow(1-Math.min(1,Math.max(0,t)),3);

  function xmur3(str){for(var i=0,h=1779033703^str.length;i<str.length;i++)h=Math.imul(h^str.charCodeAt(i),3432918353),h=h<<13|h>>>19;return function(){h=Math.imul(h^(h>>>16),2246822507);h=Math.imul(h^(h>>>13),3266489909);return(h^(h>>>16))>>>0}}
  function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
  function makeRNG(seedStr){if(!seedStr) return Math.random; const seed=xmur3(String(seedStr))(); return mulberry32(seed)}
  function roundTo(v,step){return Math.round(v/step)*step}
  function poisson(lambda,rand){if(lambda<=0) return 0; const L=Math.exp(-lambda); let k=0,p=1; do{k++;p*=rand()}while(p>L); return k-1}
  // Right‑skewed gift distribution ($50 common → $5k rare)
  function sampleGift(rand){
    const u=rand();
    if(u<0.60) return 50;
    if(u<0.78) return roundTo(50 + rand()*100, 5);
    if(u<0.90) return roundTo(150 + rand()*350, 10);
    if(u<0.98) return roundTo(500 + rand()*1500, 25);
    return roundTo(2000 + rand()*3000, 50);
  }

  // --- Parameters (250 roots) ---
  const P={ roots:250,
    lightDepth:10, lightProb:.85, lightFan:1.5, lightDecay:.90,
    extraDepth:9,  extraProb:.85, extraFan:1.8, extraDecay:.88,
    radius:800, jitter:36, cap:20000, seed:'universe-250-fallback'
  };

  // --- Build the donor graph (one‑light‑per‑parent) + births/gifts ---
  function buildGraph(P){
    const rand=makeRNG(P.seed), randJ=makeRNG(P.seed+'j'), randG=makeRNG(P.seed+'g');
    const ROOT_STAGGER=140, STEP_LIGHT=560, STEP_GREEN=420, STEP_RED=300;
    const nodes=[], links=[]; const roots=[];
    let id=0;
    function addNode(type,parent=null,branch='light',bdepth=0,birth=0){
      if(nodes.length>=P.cap) return null;
      const gift=sampleGift(randG);
      const n={id:id++,type,parent,children:[],branch,bdepth,birth,gift,x:0,y:0,z:0};
      nodes.push(n);
      if(parent!=null){links.push({source:parent,target:n.id}); nodes[parent].children.push(n.id);}
      return n;
    }
    // roots
    for(let i=0;i<P.roots;i++){ const b=i*ROOT_STAGGER + rand()*80; const r=addNode('dark',null,'light',0,b); if(r) roots.push(r.id); }
    // BFS growth
    const q=roots.map(id=>({id}));
    while(q.length && nodes.length<P.cap){
      const pid=q.shift().id; const p=nodes[pid];
      if(p.branch==='light' && p.bdepth<P.lightDepth){
        const scale=Math.pow(P.lightDecay, Math.max(0,p.bdepth));
        if(rand()<P.lightProb*scale){
          let k=poisson(Math.max(0,P.lightFan*scale), rand);
          if(k>0){
            const lb=p.birth+STEP_LIGHT*(0.8+0.4*rand());
            const c=addNode('light',pid,'light',p.bdepth+1,lb); if(c) q.push({id:c.id});
            for(let i=1;i<k;i++){ const gb=p.birth+STEP_GREEN*(0.65+0.5*rand()); const g=addNode('green',pid,'extra',1,gb); if(g) q.push({id:g.id}); }
          }
        }
      } else if(p.branch==='extra' && p.bdepth<P.extraDepth){
        const scale=Math.pow(P.extraDecay, Math.max(0,p.bdepth-1));
        if(rand()<P.extraProb*scale){
          let k=poisson(Math.max(0,P.extraFan*scale), rand);
          for(let i=0;i<k;i++){ const rb=p.birth+STEP_RED*(0.6+0.5*rand()); const r=addNode('red',pid,'extra',p.bdepth+1,rb); if(r) q.push({id:r.id}); }
        }
      }
    }
    // layout: fib sphere for roots, jitter for children
    function fibSphere(n,r=P.radius){const pts=[],phi=Math.PI*(3-Math.sqrt(5));
      for(let i=0;i<n;i++){const y=1-(i/Math.max(1,n-1))*2; const rad=Math.sqrt(Math.max(0,1-y*y)); const th=phi*i; pts.push({x:Math.cos(th)*rad*r,y:y*r,z:Math.sin(th)*rad*r});} return pts;}
    const rootsObjs=nodes.filter(n=>n.type==='dark'); const pts=fibSphere(rootsObjs.length,P.radius);
    rootsObjs.forEach((n,i)=>{n.x=pts[i].x; n.y=pts[i].y; n.z=pts[i].z;});
    nodes.forEach(n=>{
      if(n.type!=='dark'){
        const p=nodes[n.parent]||{x:0,y:0,z:0};
        const spread=P.jitter*(1+0.04*Math.max(0,n.bdepth-1));
        const j=()=> (randJ()*2-1)*spread;
        n.x=p.x+j(); n.y=p.y+j(); n.z=p.z+j();
      }
    });
    // births/gifts prefix for counters
    const byBirth=nodes.slice().sort((a,b)=>a.birth-b.birth);
    const birthsSorted=byBirth.map(n=>n.birth);
    let acc=0; const giftPrefix=byBirth.map(n=>{acc+=n.gift; return acc;});
    const maxBirth=nodes.reduce((m,n)=>Math.max(m,n.birth),0);

    return {nodes,links,roots,birthsSorted,giftPrefix,maxBirth};
  }

  // --- Counters (binary search prefix sums) ---
  function upperBound(arr,val){let lo=0,hi=arr.length; while(lo<hi){const m=(lo+hi)>>1; if(arr[m]<=val) lo=m+1; else hi=m;} return lo;}
  function updateCounters(state,t){
    const idx=upperBound(state.birthsSorted,t);
    const coins=idx, gifts=idx?state.giftPrefix[idx-1]:0, raised=coins*50 + gifts;
    coinsVal.textContent = coins.toLocaleString('en-US');
    document.getElementById('raisedVal').textContent = fmtMoney(Math.round(raised));
  }

  // --- Try to load 3D libs (global) then choose 3D or 2D ---
  async function tryLoad(src){return new Promise((res,rej)=>{const s=document.createElement('script'); s.src=src; s.async=true; s.onload=()=>res(true); s.onerror=()=>rej(new Error('load fail: '+src)); document.head.appendChild(s);});}
  async function ensureThree(){
    try { await tryLoad('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js'); }
    catch{ try { await tryLoad('https://unpkg.com/three@0.160.0/build/three.min.js'); } catch{} }
    if(!window.THREE) return false;
    try { await tryLoad('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js'); }
    catch{ try { await tryLoad('https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js'); } catch{} }
    return !!(window.THREE && THREE.OrbitControls);
  }

  // --- 3D renderer ---
  function boot3D(model){
    setStatus('3D mode');
    const rootEl=document.getElementById('app');

    const renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(2,window.devicePixelRatio||1));
    renderer.setClearColor(0x000000,1);
    rootEl.appendChild(renderer.domElement);

    const scene=new THREE.Scene(); scene.background=new THREE.Color(0x000000);
    const camera=new THREE.PerspectiveCamera(55,1,0.1,5000);
    const controls=new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping=true; controls.dampingFactor=0.05;
    scene.add(new THREE.AmbientLight(0xffffff,0.9));
    const dir=new THREE.DirectionalLight(0xffffff,0.55); dir.position.set(300,500,400); scene.add(dir);

    function size(){const w=rootEl.clientWidth||window.innerWidth, h=rootEl.clientHeight||Math.round(window.innerHeight*0.7); return {w:Math.max(1,w),h:Math.max(1,h)}}
    function resize(){const {w,h}=size(); camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false)} window.addEventListener('resize',resize);
    function resetView(){camera.position.set(0,0,950); controls.target.set(0,0,0); controls.update()} resetView(); resize();

    const COLOR={dark:0x1e3a8a, light:0x93c5fd, green:0x22c55e, red:0xef4444, edge:0x5b6b95};
    const spheres=[];

    // Nodes
    model.nodes.forEach(n=>{
      const size = n.type==='dark'?5.2 : n.type==='light'?4 : n.type==='green'?4.4 : 3.8;
      const col = n.type==='dark'?COLOR.dark:n.type==='light'?COLOR.light:n.type==='green'?COLOR.green:COLOR.red;
      const mat=new THREE.MeshStandardMaterial({color:col, metalness:.15, roughness:.45, transparent:true, opacity:0});
      const mesh=new THREE.Mesh(new THREE.SphereGeometry(size,18,18), mat);
      mesh.position.set(n.x,n.y,n.z); mesh.userData.id=n.id; mesh.userData.birth=n.birth; mesh.scale.setScalar(0.001);
      spheres.push(mesh); scene.add(mesh);
    });

    // Edges (faint static)
    const pos=new Float32Array(model.links.length*6); let k=0;
    model.links.forEach(l=>{const s=model.nodes[l.source], t=model.nodes[l.target];
      pos[k++]=s.x; pos[k++]=s.y; pos[k++]=s.z; pos[k++]=t.x; pos[k++]=t.y; pos[k++]=t.z;});
    const edgeGeo=new THREE.BufferGeometry(); edgeGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const edges=new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({color:COLOR.edge, transparent:true, opacity:0.12}));
    scene.add(edges);

    // Growing cyan edges ordered by child birth
    const sorted=model.links.slice().sort((a,b)=> model.nodes[a.target].birth - model.nodes[b.target].birth);
    const posGrow=new Float32Array(sorted.length*6); let g=0; const births=new Float32Array(sorted.length);
    sorted.forEach((l,i)=>{const s=model.nodes[l.source], t=model.nodes[l.target];
      posGrow[g++]=s.x; posGrow[g++]=s.y; posGrow[g++]=s.z; posGrow[g++]=t.x; posGrow[g++]=t.y; posGrow[g++]=t.z; births[i]=model.nodes[l.target].birth;});
    const growGeo=new THREE.BufferGeometry(); growGeo.setAttribute('position', new THREE.BufferAttribute(posGrow,3));
    growGeo.setDrawRange(0,0);
    const grow=new THREE.LineSegments(growGeo, new THREE.LineBasicMaterial({color:0x6ee7ff, transparent:true, opacity:0.9}));
    scene.add(grow);

    // Picking + highlight
    const ray=new THREE.Raycaster(), mouse=new THREE.Vector2(); let glow=null;
    function clearHi(){ if(glow){scene.remove(glow); glow.geometry.dispose(); glow.material.dispose(); glow=null;} spheres.forEach(m=>{m.material.opacity=1; m.material.transparent=true}); edges.material.opacity=0.12; }
    function highlight(id){
      clearHi();
      const keep=new Set([id]); const q=[id];
      while(q.length){const cur=q.shift(); model.nodes[cur].children.forEach(ch=>{if(!keep.has(ch)){keep.add(ch); q.push(ch)}})}
      spheres.forEach(m=>{const on=keep.has(m.userData.id); m.material.opacity=on?1:0.10;});
      const kept=model.links.filter(l=> keep.has(l.source)&&keep.has(l.target));
      const dpos=new Float32Array(kept.length*6); let i=0;
      kept.forEach(l=>{const s=model.nodes[l.source], t=model.nodes[l.target];
        dpos[i++]=s.x; dpos[i++]=s.y; dpos[i++]=s.z; dpos[i++]=t.x; dpos[i++]=t.y; dpos[i++]=t.z;});
      const geo=new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.BufferAttribute(dpos,3));
      glow=new THREE.LineSegments(geo,new THREE.LineBasicMaterial({color:0x06b6d4,transparent:true,opacity:.95}));
      scene.add(glow);

      // Influence so far
      const t=BLOOM.t;
      const visible=[...keep].filter(i=> model.nodes[i].birth<=t);
      const coins=visible.length;
      const gifts=visible.reduce((s,i)=>s+model.nodes[i].gift,0);
      const raised=coins*50+gifts;
      const selfGift=model.nodes[id].gift+50; const network=raised-selfGift;
      setStatus(`selected #${id} — direct ${fmtMoney(selfGift)} · constellation ${coins-1} others raising ${fmtMoney(network)} (total ${fmtMoney(raised)})`);
    }
    renderer.domElement.addEventListener('pointerup',ev=>{
      const rect=renderer.domElement.getBoundingClientRect();
      mouse.x=((ev.clientX-rect.left)/rect.width)*2-1; mouse.y=-((ev.clientY-rect.top)/rect.height)*2+1;
      ray.setFromCamera(mouse,camera); const hits=ray.intersectObjects(spheres,true);
      if(hits.length) highlight(hits[0].object.userData.id); else clearHi();
    });

    // Bloom timeline
    const BLOOM={playing:true,t:0,duration:model.maxBirth+2000,start:performance.now()};
    function applyBloom(){
      const t=BLOOM.t;
      for(const m of spheres){
        const n=model.nodes[m.userData.id]; const a=easeOutCubic((t-n.birth)/420);
        if(a<=0){ m.visible=false; continue; } m.visible=true; m.scale.setScalar(0.001 + Math.max(0,Math.min(1,a))); m.material.opacity=Math.max(0,Math.min(1,a));
      }
      // edges grow
      const arr=births; let lo=0,hi=arr.length; while(lo<hi){const mid=(lo+hi)>>1; if(arr[mid]<=t) lo=mid+1; else hi=mid;}
      grow.geometry.setDrawRange(0, lo*2);
      updateCounters(model,t);
      tlFill.style.width = `${Math.min(100,(t/BLOOM.duration)*100)}%`;
    }

    // Controls
    document.getElementById('btnBloom').addEventListener('click',()=>{ BLOOM.playing=!BLOOM.playing; document.getElementById('btnBloom').textContent=BLOOM.playing?'⏸ Bloom':'⏵ Bloom'; if(BLOOM.playing) BLOOM.start=performance.now()-BLOOM.t;});
    window.addEventListener('keydown',e=>{
      if(e.key==='b'||e.key==='B'){ if(e.shiftKey){BLOOM.t=0; BLOOM.playing=false; document.getElementById('btnBloom').textContent='⏵ Bloom'; tlFill.style.width='0%';} else {BLOOM.playing=!BLOOM.playing; document.getElementById('btnBloom').textContent=BLOOM.playing?'⏸ Bloom':'⏵ Bloom'; if(BLOOM.playing) BLOOM.start=performance.now()-BLOOM.t;}}
      if(e.key==='h'||e.key==='H') helpEl.classList.toggle('open');
    });
    document.getElementById('btnHelp').addEventListener('click', ()=> helpEl.classList.toggle('open'));

    // Loop
    function loop(){
      if(BLOOM.playing){ BLOOM.t=Math.min(BLOOM.duration, performance.now()-BLOOM.start); if(BLOOM.t>=BLOOM.duration){ BLOOM.playing=false; document.getElementById('btnBloom').textContent='⏵ Bloom'; } }
      applyBloom(); controls.update(); renderer.render(scene,camera); requestAnimationFrame(loop);
    }
    loop(); setStatus(`ready — 3D (${model.nodes.length} donors)`);

    // helpers
    function poisson(lambda,rand){if(lambda<=0) return 0; const L=Math.exp(-lambda); let k=0,p=1; do{k++;p*=rand()}while(p>L); return k-1}
  }

  // --- 2D fallback renderer (Canvas) ---
  function boot2D(model){
    setStatus('2D fallback (CDN blocked) — all features active');
    const app=document.getElementById('app');
    const canvas=document.createElement('canvas'); app.appendChild(canvas);
    const ctx=canvas.getContext('2d');
    function resize(){const dpr=window.devicePixelRatio||1; const w=app.clientWidth||window.innerWidth, h=app.clientHeight||window.innerHeight; canvas.width=w*dpr; canvas.height=h*dpr; canvas.style.width=w+'px'; canvas.style.height=h+'px'; ctx.setTransform(dpr,0,0,dpr,0,0);}
    window.addEventListener('resize',resize); resize();

    // camera-ish params
    let yaw=0, pitch=0, dist=1100, tx=0, ty=0, dragging=false, rotating=false, lastX=0,lastY=0;
    canvas.addEventListener('mousedown',e=>{dragging=true; rotating=e.button===2 || e.ctrlKey; lastX=e.clientX; lastY=e.clientY;});
    window.addEventListener('mouseup',()=>dragging=false);
    window.addEventListener('contextmenu',e=>{if(e.target===canvas) e.preventDefault();});
    window.addEventListener('mousemove',e=>{
      if(!dragging) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
      if(rotating){ yaw+=dx*0.005; pitch=Math.max(-1.2, Math.min(1.2, pitch+dy*0.005)); }
      else { tx+=dx; ty+=dy; }
    });
    canvas.addEventListener('wheel',e=>{ e.preventDefault(); dist=Math.max(200, Math.min(3000, dist + e.deltaY)); }, {passive:false});

    // project 3D -> 2D with yaw/pitch + simple perspective
    function project(v){
      // rotate around Y (yaw), then X (pitch)
      const cosy=Math.cos(yaw), siny=Math.sin(yaw);
      const cosx=Math.cos(pitch), sinx=Math.sin(pitch);
      let x=v.x*cosy - v.z*siny;
      let z=v.x*siny + v.z*cosy;
      let y=v.y*cosx - z*sinx;
      z = v.y*sinx + z*cosx;
      const f=dist; const s=f/(f+z+1e-3);
      return {x:x*s + canvas.width/(window.devicePixelRatio||1)/2 + tx, y:y*s + canvas.height/(window.devicePixelRatio||1)/2 + ty, s};
    }

    // color + size
    const COLOR={dark:'#1e3a8a', light:'#93c5fd', green:'#22c55e', red:'#ef4444', edge:'rgba(91,107,149,0.12)', glow:'#06b6d4'};
    const sizeOf=(t)=> t==='dark'?5.2 : t==='light'?4 : t==='green'?4.4 : 3.8;

    // precompute projected positions each frame
    const screenPos=new Array(model.nodes.length);

    // picking
    function pick(mx,my){
      let best=-1, bestD=12; // px
      for(let i=0;i<model.nodes.length;i++){
        const p=screenPos[i]; if(!p || p.s<=0) continue;
        const dx=mx-p.x, dy=my-p.y; const d=Math.hypot(dx,dy);
        if(d<bestD){ bestD=d; best=i; }
      }
      return best;
    }

    // highlight set
    let highlightSet=null;

    canvas.addEventListener('click',e=>{
      const rect=canvas.getBoundingClientRect(); const id=pick(e.clientX-rect.left, e.clientY-rect.top);
      if(id>=0){
        const keep=new Set([id]); const q=[id];
        while(q.length){const cur=q.shift(); model.nodes[cur].children.forEach(ch=>{if(!keep.has(ch)){keep.add(ch); q.push(ch)}})}
        highlightSet=keep;
        const t=BLOOM.t;
        const visible=[...keep].filter(i=> model.nodes[i].birth<=t);
        const coins=visible.length;
        const gifts=visible.reduce((s,i)=>s+model.nodes[i].gift,0);
        const raised=coins*50+gifts;
        const selfGift=model.nodes[id].gift+50; const network=raised-selfGift;
        setStatus(`selected #${id} — direct ${fmtMoney(selfGift)} · constellation ${coins-1} others raising ${fmtMoney(network)} (total ${fmtMoney(raised)})`);
      } else {
        highlightSet=null;
      }
    });

    // Bloom clock
    const BLOOM={playing:true,t:0,duration:model.maxBirth+2000,start:performance.now()};
    document.getElementById('btnBloom').addEventListener('click',()=>{ BLOOM.playing=!BLOOM.playing; document.getElementById('btnBloom').textContent=BLOOM.playing?'⏸ Bloom':'⏵ Bloom'; if(BLOOM.playing) BLOOM.start=performance.now()-BLOOM.t;});
    window.addEventListener('keydown',e=>{
      if(e.key==='b'||e.key==='B'){ if(e.shiftKey){BLOOM.t=0; BLOOM.playing=false; document.getElementById('btnBloom').textContent='⏵ Bloom'; tlFill.style.width='0%';} else {BLOOM.playing=!BLOOM.playing; document.getElementById('btnBloom').textContent=BLOOM.playing?'⏸ Bloom':'⏵ Bloom'; if(BLOOM.playing) BLOOM.start=performance.now()-BLOOM.t;}}
      if(e.key==='h'||e.key==='H') helpEl.classList.toggle('open');
    });
    document.getElementById('btnHelp').addEventListener('click', ()=> helpEl.classList.toggle('open'));

    // draw loop
    function draw(){
      const w=canvas.width/(window.devicePixelRatio||1), h=canvas.height/(window.devicePixelRatio||1);
      ctx.clearRect(0,0,w,h);

      // update bloom clock
      if(BLOOM.playing){ BLOOM.t=Math.min(BLOOM.duration, performance.now()-BLOOM.start); if(BLOOM.t>=BLOOM.duration){ BLOOM.playing=false; document.getElementById('btnBloom').textContent='⏵ Bloom'; } }

      // project all nodes
      for(let i=0;i<model.nodes.length;i++) screenPos[i]=project(model.nodes[i]);

      // faint edges
      ctx.lineWidth=1; ctx.strokeStyle=COLOR.edge; ctx.beginPath();
      for(const l of model.links){
        const a=screenPos[l.source], b=screenPos[l.target]; if(!a||!b) continue;
        ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
      }
      ctx.stroke();

      // growing cyan edges (child birth <= t)
      ctx.lineWidth=1; ctx.strokeStyle='rgba(110,231,255,0.9)'; ctx.beginPath();
      for(const l of model.links){
        if(model.nodes[l.target].birth > BLOOM.t) break; // links not strictly sorted, but OK visually
        const a=screenPos[l.source], b=screenPos[l.target]; if(!a||!b) continue;
        ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
      }
      ctx.stroke();

      // nodes
      for(const n of model.nodes){
        const p=screenPos[n.id]; if(!p) continue;
        const a=easeOutCubic((BLOOM.t - n.birth)/420); if(a<=0) continue;
        let r = sizeOf(n.type) * (0.6 + 0.6*p.s) * a; // perspective-ish
        const col = n.type==='dark'?COLOR.dark:n.type==='light'?COLOR.light:n.type==='green'?COLOR.green:COLOR.red;
        ctx.globalAlpha = highlightSet ? (highlightSet.has(n.id)?1:0.10) : a;
        ctx.beginPath(); ctx.fillStyle=col; ctx.arc(p.x,p.y,Math.max(1,r),0,Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha = 1;

      // counters + timeline
      updateCounters(model,BLOOM.t);
      tlFill.style.width = `${Math.min(100,(BLOOM.t/BLOOM.duration)*100)}%`;

      requestAnimationFrame(draw);
    }
    draw();
  }

  // --- Boot sequence ---
  const model = buildGraph(P);
  // Try 3D; if it fails, run 2D.
  (async () => {
    try{
      setStatus('loading 3D engine…');
      const ok = await ensureThree();
      if(ok) boot3D(model); else boot2D(model);
    } catch(e){
      console.warn('3D load error, using 2D fallback:', e);
      boot2D(model);
    }
  })();

  // UI toggles
  document.getElementById('btnHelp').addEventListener('click', ()=> helpEl.classList.toggle('open'));
})();
</script>
</body>
</html>
